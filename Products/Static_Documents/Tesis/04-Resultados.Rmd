Este capítulo aborda los principales resultados a partir del procedimiento descrito en la metodología. Cada sección de este capítulo tendrá una subsección donde se aplica cada etapa de análisis a las respectivas series cronológicas.

\subsection{Análisis exploratorio}

Inicialmente, se analizan las series cronológicas para verificar su comportamiento al ajustar un suavizamiento de Loess para buscar señales de tendencia y concavidad en los datos temporales, y buscar indicios de los procesos que gobiernan dichas series, además someterlas a prueba para verificar que se trate de series cronológicas estacionarias.

```{r funcion_exploratorio}
exploratorio <-
    function(datos,
             diferenciar = FALSE,
             logaritmo = FALSE,
             diferenciar_logaritmo = FALSE,
             mostrar=c("comportamiento", "acf", "pacf"),
             temporalidad=NULL) {
        
        if (diferenciar) {
            datos <- diff(datos)
        }
        
        if (logaritmo) {
            datos <- log(datos)
        }
        
        if (diferenciar_logaritmo) {
            datos <- diff(log(datos))
        }
        
        comportamiento <- datos %>%
            ggplot() +
            geom_line(color = "#00AFBB", size = 1.3) +
            stat_smooth(color = "#FC4E07",
                        fill = "#FC4E07",
                        method = "loess") +
            # geom_vline(xintercept = 2000.6, linetype="dashed", color = "red")+
            theme_minimal() +
            theme(text = element_text(size = 9),
                  axis.text.x = element_text(angle = 0, hjust = 1)) +
            # labs(caption="Fuente: UED-INEC",
            #      y="TMII (por cada 1000 nacimientos)",
            #      x="Año") +
            theme(
                plot.title = element_text(hjust = 0.5, face = "plain"),
                plot.caption = element_text(
                    hjust = 0,
                    vjust = 0.5,
                    margin = margin(t = 1, 10, 10, 10)
                )
            )# +
        # scale_x_discrete(expand = c(0,0), limits=c(1995, 2005, 2015))
        #scale_x_discrete(expand = c(0,0))
        
        if(mostrar=="comportamiento"){
            return(comportamiento)
        }
        
        if(mostrar=="acf" & is.null(temporalidad)){
            acf(datos, main="", xlab="Rezagos")
        }
        
        if(mostrar=="pacf" & is.null(temporalidad)){
            pacf(datos, main="", xlab="Rezagos", ylab="PACF")
        }
        
        if(mostrar=="acf" & !is.null(temporalidad)){
            ACF <- acf(datos, plot = FALSE, lag.max = temporalidad*3)
            
            ACF$lag <- ACF$lag*temporalidad
            
            plot(ACF, main="", xlab="Rezagos", ylab="ACF")
        }
        
        if(mostrar=="pacf" & !is.null(temporalidad)){
            PACF <- pacf(datos, plot = FALSE, lag.max = temporalidad*3)
            
            PACF$lag <- PACF$lag*temporalidad
            
            plot(PACF, main="", xlab="Rezagos", ylab="PACF")
        }
        
      
    }
```

\subsubsection{Datos simulados}

En la figura \ref{fig:series_simuladas} se mostró el comportamiento general de cada una de las series cronológicas simuladas. Al tratarse de datos simulados se conoce de previo el proceso que gobierna a cada una de las series temporales, por lo que verificar la estacioneriedad y obtener los correlogramas sirve para confirmar que los procesos siguen aproximadamente los procesos planteados.

```{r}
arima100 <- resultados_no_estacional_bajo[[1]]$datos 

arima101 <- resultados_no_estacional_bajo[[2]]$datos 

arima203 <- resultados_no_estacional_alto[[1]]$datos 

arima402 <- resultados_no_estacional_alto[[2]]$datos 

arima001_011 <- resultados_estacional_bajo[[1]]$datos 

arima214_303 <- resultados_estacional_alto[[2]]$datos 
```


\paragraph{ARIMA(1,0,0)}

En la figura \ref{fig:arima100_comportamiento} puede verse como los datos simulados bajo este proceso se comportan de manera ligeramente oscilante a lo largo del tiempo sin necesidad de aplicar ninguna transformación a los datos. Además, la figura \ref{fig:arima100_acf} muestra como las autocorrelaciones caen moderadamente rápidamente a cero y van disminuyendo, mientras que la figura \ref{fig:arima100_pacf} se corta al inicio, lo que sugiere que se está en presencia de un proceso $ARIMA(1,0,0)$, tal y como fue planteado al simular los datos.

```{r arima100_comportamiento, fig.cap="Tendencia de los datos simulados a partir de un proceso ARIMA(1,0,0)"}
exploratorio(arima100, mostrar = "comportamiento")
```

```{r arima100_acf, fig.cap="Autocorrelación de los datos simulados a partir de un proceso ARIMA(1,0,0)"}
exploratorio(arima100, mostrar = "acf")
```

```{r arima100_pacf, fig.cap="Autocorrelación parcial de los datos simulados a partir de un proceso ARIMA(1,0,0)"}
exploratorio(arima100, mostrar = "pacf")
```

\paragraph{ARIMA(1,0,1)}

En la figura \ref{fig:arima101_comportamiento} puede verse como los datos simulados bajo este proceso se comportan de manera más oscilante que el caso anterior a lo largo del tiempo. Además, la figura \ref{fig:arima101_acf} muestra como las autocorrelaciones van disminuyendo muy lentamente, mientras que se aprecia en la figura \ref{fig:arima101_pacf} que hay un comportamiento similar al caso anterior, pues también va disminuyendo, lo que sugiere que el posible proceso que gobierna los datos podría tratarse de un $ARIMA(1,0,1)$, tal y como fue planteado al simular los datos.

```{r arima101_comportamiento, fig.cap="Tendencia de los datos simulados a partir de un proceso ARIMA(1,0,1)"}
exploratorio(arima101, mostrar = "comportamiento")
```

```{r arima101_acf, fig.cap="Autocorrelación de los datos simulados a partir de un proceso ARIMA(1,0,1)"}
exploratorio(arima101, mostrar = "acf")
```

```{r arima101_pacf, fig.cap="Autocorrelación parcial de los datos simulados a partir de un proceso ARIMA(1,0,1)"}
exploratorio(arima101, mostrar = "pacf")
```

\paragraph{ARIMA(2,0,3)}

En la figura \ref{fig:arima203_comportamiento} se observa como los datos simulados bajo este proceso no parecen tener ninguna tendencia clara, una alternativa en este caso sería aplicar alguna transformación para volverla aún más estacionaria. La figura \ref{fig:arima203_acf} muestra como las autocorrelaciones van disminuyendo, situación no tan clara en la figura \ref{fig:arima203_pacf}, este escenario sugiere que se está en presencia de un proceso $ARMA(p,q)$, por lo que podrían ajustarse varios modelos $ARIMA(p,d,q)$ hasta encontrar el más adecuado.

```{r arima203_comportamiento, fig.cap="Tendencia de los datos simulados a partir de un proceso ARIMA(2,0,3)"}
exploratorio(arima203, mostrar = "comportamiento")
```

```{r arima203_acf, fig.cap="Autocorrelación de los datos simulados a partir de un proceso ARIMA(2,0,3)"}
exploratorio(arima203, mostrar = "acf")
```

```{r arima203_pacf, fig.cap="Autocorrelación parcial de los datos simulados a partir de un proceso ARIMA(2,0,3)"}
exploratorio(arima203, mostrar = "pacf")
```

\paragraph{ARIMA(4,0,2)}

En la figura \ref{fig:arima402_comportamiento} se observa como los datos simulados bajo este proceso tampoco parecen tener una tendencia claramente definida, por lo que podría ser necesario aplicar alguna transformación. Las figuras \ref{fig:arima402_acf} y \ref{fig:arima402_pacf} presentan una situación similar a la anterior, por lo que podrían ajustarse varios modelos $ARIMA(p,d,q)$ hasta encontrar el más adecuado.

```{r arima402_comportamiento, fig.cap="Tendencia de los datos simulados a partir de un proceso ARIMA(4,0,2)"}
exploratorio(arima402, mostrar = "comportamiento")
```

```{r arima402_acf, fig.cap="Autocorrelación de los datos simulados a partir de un proceso ARIMA(4,0,2)"}
exploratorio(arima402, mostrar = "acf")
```

```{r arima402_pacf, fig.cap="Autocorrelación parcial de los datos simulados a partir de un proceso ARIMA(4,0,2)"}
exploratorio(arima402, mostrar = "pacf")
```

\paragraph{ARIMA(0,0,1)(0,1,1)}

En la figura \ref{fig:arima001_011_comportamiento} los datos parecen ser aproximadamente estacionarios, pero esto no es del todo claro; una transformación no es estrictamente necesaria, pero puede aplicarse para corregir ligeramente la parte estacional. Las figuras \ref{fig:arima001_011_acf} y \ref{fig:arima001_011_pacf}, sugieren estar en presencia de un proceso estacional cada 12 periodos, por lo que la estimación de modelos $ARIMA$ de bajo nivel podría ser suficiente..

```{r arima001_011_comportamiento, fig.cap="Tendencia de los datos simulados a partir de un proceso ARIMA(0,0,1)(0,1,1)"}
exploratorio(arima001_011, mostrar = "comportamiento")
```

```{r arima001_011_acf, fig.cap="Autocorrelación de los datos simulados a partir de un proceso ARIMA(0,0,1)(0,1,1)"}
exploratorio(arima001_011, mostrar = "acf", temporalidad = 12)
```

```{r arima001_011_pacf, fig.cap="Autocorrelación parcial de los datos simulados a partir de un proceso ARIMA(0,0,1)(0,1,1)"}
exploratorio(arima001_011, mostrar = "pacf", temporalidad = 12)
```

\paragraph{ARIMA(2,1,4)(3,0,3)}

En la figura \ref{fig:arima214_303_comportamiento} se manifiesta una clara tendencia bajista. Las figuras \ref{fig:arima214_303_acf} y \ref{fig:arima214_303_pacf} no permiten identificar claramente el proceso que gobierna la serie, por lo que habría que probar distintos modelos $ARIMA$ hasta encontrar el más adecuado.

```{r arima214_303_comportamiento, fig.cap="Tendencia de los datos simulados a partir de un proceso ARIMA(2,1,4)(3,0,3)"}
exploratorio(arima214_303, mostrar = "comportamiento")
```

```{r arima214_303_acf, fig.cap="Autocorrelación de los datos simulados a partir de un proceso ARIMA(2,1,4)(3,0,3)"}
exploratorio(arima214_303, mostrar = "acf", temporalidad = 12)
```

```{r arima214_303_pacf, fig.cap="Autocorrelación parcial de los datos simulados a partir de un proceso ARIMA(2,1,4)(3,0,3)"}
exploratorio(arima214_303, mostrar = "pacf", temporalidad = 12)
```

\subsubsection{Tasa de mortalidad infantil interanual}

```{r}
base <- popstudy::read_from_dir("TMIIR.xlsx", "References/Results_section_references/01 - Tasa de mortalidad infantil interanual") %>% 
  read_excel()
#base <- read_excel("./Material de referencia/Para sección de resultados/01 - Tasa de mortalidad infantil interanual/TMIIR.xlsx")
TS <- ts(base$tmii, start = c(1989, 1), end = c(2017, 12), frequency = 12)
```

Como se mostró en la figura \ref{fig:tmiiplotgeneral}, la tasa de mortalidad infantil interanual posee una tendencia claramente decreciente, por lo que su media, por lo que no se trata de una serie cronológica estacionaria. Tras aplicarle una diferenciación, esta situación cambia, tal y como se muestra en la figura \ref{fig:tmii_comportamiento}.

Por otro lado, las figuras \ref{fig:tmii_acf} y \ref{fig:tmii_pacf} sugieren la presencia de procesos estacionales , mientras que en la parte no estacional se observa como la *ACF* va disminuyendo y el *PACF* se corta tras el segundo rezado, lo cual podría ser indicio de un proceso $MA(2)$ o superior.

```{r tmii_comportamiento, fig.cap="Tendencia de los datos diferenciados de la TMII"}
exploratorio(TS, mostrar = "comportamiento", diferenciar = T)
```

```{r tmii_acf, fig.cap="Autocorrelación de los datos diferenciados de la TMII"}
exploratorio(TS, mostrar = "acf", temporalidad = 12, diferenciar = T)
```

```{r tmii_pacf, fig.cap="Autocorrelación parcial de los datos diferenciados de la TMII"}
exploratorio(TS, mostrar = "pacf", temporalidad = 12, diferenciar = T)
```

\subsubsection{Mortalidad por causa externa}

```{r}
load(popstudy::read_from_dir("data.RData", "References/Results_section_references/03 - Mortalidad por causa externa"))
TS <- ts(base$Total, start = c(2000, 1), end = c(2017, 12), frequency = 12)
```

En la figura \ref{fig:externaplotgeneral} se observó como la tasa de mortalidad por causa externa posee una tendencia ligeramente creciente e inestable a lo largo del tiempo, por lo que no se trata de una serie cronológica estacionaria. Tras aplicarle una diferenciación la serie se comporta como lo mostrado en la figura \ref{fig:externa_comportamiento}. Además, las figuras \ref{fig:externa_acf} y \ref{fig:externa_pacf} muestran indicios de un proceso bajo en la parte no estacional, y si bien no hay indicios claros de patrones estacionales, es sabido que los meses de Enero, Abril y Diciembre son los que cuentan con un mayor número de defunciones por estas causas.

```{r externa_comportamiento, fig.cap="Tendencia de los datos diferenciados de la mortalidad por causa externa"}
exploratorio(TS, mostrar = "comportamiento", diferenciar = T)
```

```{r externa_acf, fig.cap="Autocorrelación de los datos diferenciados de la mortalidad por causa externa"}
exploratorio(TS, mostrar = "acf", temporalidad = 12, diferenciar = T)
```

```{r externa_pacf, fig.cap="Autocorrelación parcial de los datos diferenciados de la mortalidad por causa externa"}
exploratorio(TS, mostrar = "pacf", temporalidad = 12, diferenciar = T)
```

\subsubsection{Incentivos salariales}

```{r}
base <- popstudy::read_from_dir("Datos examen1.xlsx", "References/Results_section_references/04 - Incentivos salariales del sector público") %>% 
  read_excel() %>% 
  #read_excel(".\\Material de referencia\\Para sección de resultados\\04 - Incentivos salariales del sector público\\Datos examen1.xlsx") %>% 
  mutate(valor=`Incentivos salariales`,
         fecha=ymd(Fecha)) %>% 
  select(fecha, valor)
TS <- ts(base$valor, start = c(2007, 1), end = c(2015, 06), frequency = 12)
```

En la figura \ref{fig:incentivosplotgeneral} se observó como la serie de incentivos salariales posee una tendencia creciente y sostenida a lo largo del tiempo, por lo que no se trata de una serie cronológica estacionaria. Tras una diferenciación la serie se comporta como lo mostrado en la figura \ref{fig:incentivos_comportamiento}, que aunque su media se mantiene constante, parece seguir teniendo patrones. Además, las figuras \ref{fig:incentivos_acf} y \ref{fig:incentivos_pacf} no parecen sugerir un proceso en particular tanto para la parte estacional como para la no estacional, a pesar de que es claro que existe un efecto periódico.

```{r incentivos_comportamiento, fig.cap="Tendencia de los datos diferenciados de la serie de incentivos salariales"}
exploratorio(TS, mostrar = "comportamiento", diferenciar = T)
```

```{r incentivos_acf, fig.cap="Autocorrelación de los datos diferenciados de la serie de incentivos salariales"}
exploratorio(TS, mostrar = "acf", temporalidad = 12, diferenciar = T)
```

```{r incentivos_pacf, fig.cap="Autocorrelación parcial de los datos diferenciados de la serie de incentivos salariales"}
exploratorio(TS, mostrar = "pacf", temporalidad = 12, diferenciar = T)
```

\subsubsection{Intereses y comisiones del sector público}

```{r}
base <- popstudy::read_from_dir("Datos examen2.xlsx", "References/Results_section_references/05 - Intereses y comisiones del sector público") %>% 
  read_excel() %>%
  #read_excel(".\\Material de referencia\\Para sección de resultados\\05 - Intereses y comisiones del sector público\\Datos examen2.xlsx") %>% 
  mutate(valor=`Intereses y comisiones`,
         fecha=ymd(Fecha)) %>% 
  select(fecha, valor) %>% 
  filter(year(fecha)>=2009)
TS <- ts(base$valor, start = c(2009, 1), end = c(2018, 06), frequency = 12)
```

En la figura \ref{fig:interesesplotgeneral} se muestra como la serie de intereses y comisiones del sector público posee una tendencia creciente no lineal, por lo que no se trata de una serie de tiempo estacionaria. Tras utilizar una diferenciación la serie se comporta como lo mostrado en la figura \ref{fig:intereses_comportamiento}, que aunque su media se mantiene constante, pero aún conserva algunos patrones. Las figuras \ref{fig:intereses_acf} y \ref{fig:intereses_pacf} indican que existen un efecto estacional, pero su identificación no es clara.

```{r intereses_comportamiento, fig.cap="Tendencia de los datos diferenciados de la serie de intereses y comisiones del sector público"}
exploratorio(TS, mostrar = "comportamiento", diferenciar = T)
```

```{r intereses_acf, fig.cap="Autocorrelación de los datos diferenciados de la serie de intereses y comisiones del sector público"}
exploratorio(TS, mostrar = "acf", temporalidad = 12, diferenciar = T)
```

```{r intereses_pacf, fig.cap="Autocorrelación parcial de los datos diferenciados de la serie de intereses y comisiones del sector público"}
exploratorio(TS, mostrar = "pacf", temporalidad = 12, diferenciar = T)
```

\subsection{Partición de los datos}

Como se mencionó en la metodología, la partición utilizada consiste en tomar 80% de las observaciones para generar el serie cronológica de entrenamiento para ajustar los modelos, mientras que el restante 20% corresponde al la serie cronológica utilizada como validación. En el caso de los datos simulados, la ventana de observación de los datos seleccionados se muestra en la figura \ref{fig:particion_series_simuladas} para los datos simulados, y en la figura \ref{fig:particion_series_reales} para las series de tiempo reales.

```{r particion_series_simuladas, fig.cap="Partición de los datos en los conjuntos de entrenamiento y validación para las series de tiempo simuladas"}
particiones <-
    function(serie,
             training = .8,
             titulo = "",
             ejex = "X",
             ejey = "Y") {
        corte <- round(length(serie) * training, 0)
        train <<- subset(serie, end = corte)
        test <<- subset(serie, start = corte + 1)
        
        minimo_training <- attributes(train)$tsp[1]
        maximo_training <- attributes(train)$tsp[2]
        
        minimo_testing <- attributes(test)$tsp[1]
        maximo_testing <- attributes(test)$tsp[2]
        
        exploratorio(serie) +
            annotate(
                "rect",
                xmin = minimo_training,
                xmax = maximo_training,
                ymin = min(serie),
                ymax = Inf,
                alpha = 0.3,
                fill = "green",
                linetype = "dashed"
            ) +
            annotate(
                "rect",
                xmin = maximo_training,
                xmax = maximo_testing,
                ymin = min(serie),
                ymax = Inf,
                alpha = 0.3,
                fill = "blue",
                linetype = "dashed"
            ) +
            labs(y = ejey,
                 x = ejex) +
            ggtitle(titulo)
        
        
    }

particion_arima100 <-
    particiones(arima100,
                titulo = "ARIMA(1,0,0)",
                ejex = "t",
                ejey = "Y")

particion_arima101 <-
    particiones(arima101,
                titulo = "ARIMA(1,0,1)",
                ejex = "t",
                ejey = "Y")

particion_arima203 <-
    particiones(arima203,
                titulo = "ARIMA(2,0,3)",
                ejex = "t",
                ejey = "Y")

particion_arima402 <-
    particiones(arima402,
                titulo = "ARIMA(4,0,2)",
                ejex = "t",
                ejey = "Y")

particion_arima001_011 <-
    particiones(arima001_011,
                titulo = "ARIMA(0,0,1)(0,1,1)",
                ejex = "t",
                ejey = "Y")

particion_arima214_303 <-
    particiones(arima214_303,
                titulo = "ARIMA(2,1,4)(3,0,3)",
                ejex = "t",
                ejey = "Y")

ggarrange(
    particion_arima100,
    particion_arima101,
    particion_arima203,
    particion_arima402,
    particion_arima001_011,
    particion_arima214_303,
    ncol = 3,
    nrow = 2
)
```

```{r particion_series_reales, fig.cap="Partición de los datos en los conjuntos de entrenamiento y validación para las series de tiempo reales"}

base <-
    popstudy::read_from_dir(
        "TMIIR.xlsx",
        "References/Results_section_references/01 - Tasa de mortalidad infantil interanual"
    ) %>%
    read_excel()
TS_tmii <-
    ts(
        base$tmii,
        start = c(1989, 1),
        end = c(2017, 12),
        frequency = 12
    )

particion_tmii <-
    particiones(TS_tmii,
                titulo = "TMII",
                ejex = "Año",
                ejey = "Tasa")

#######################
load(
    popstudy::read_from_dir(
        "data.RData",
        "References/Results_section_references/03 - Mortalidad por causa externa"
    )
)
TS_externa <-
    ts(
        base$Total,
        start = c(2000, 1),
        end = c(2017, 12),
        frequency = 12
    )
particion_externa <-
    particiones(TS_externa,
                titulo = "Mortalidad por causa externa",
                ejex = "Año",
                ejey = "Tasa")

#########################

base <-
    popstudy::read_from_dir(
        "Datos examen1.xlsx",
        "References/Results_section_references/04 - Incentivos salariales del sector público"
    ) %>%
    read_excel() %>%
    mutate(valor = `Incentivos salariales`,
           fecha = ymd(Fecha)) %>%
    select(fecha, valor)
TS_incentivos <-
    ts(
        base$valor,
        start = c(2007, 1),
        end = c(2015, 06),
        frequency = 12
    )

particion_incentivos <-
    particiones(TS_incentivos,
                titulo = "Incentivos salariales",
                ejex = "Año",
                ejey = "Incentivos")

########################
base <-
    popstudy::read_from_dir(
        "Datos examen2.xlsx",
        "References/Results_section_references/05 - Intereses y comisiones del sector público"
    ) %>%
    read_excel() %>%
    mutate(valor = `Intereses y comisiones`,
           fecha = ymd(Fecha)) %>%
    select(fecha, valor) %>%
    filter(year(fecha) >= 2009)
TS_intereses <-
    ts(
        base$valor,
        start = c(2009, 1),
        end = c(2018, 06),
        frequency = 12
    )
particion_intereses <-
    particiones(TS_intereses,
                titulo = "Intereses y comisiones",
                ejex = "Año",
                ejey = "Intereses y comisiones")

ggarrange(
    particion_tmii,
    particion_externa,
    particion_incentivos,
    particion_intereses,
    ncol = 2,
    nrow = 2
)
```

\subsection{Identificación y estimación del mejor modelo según la función auto.arima()}

Al ajustar modelos con la función `auto.arima()`, al igual que con cualquier otro método para estimar modelos $ARIMA$, se obtienen estimaciones de coeficientes. En el caso de los datos simulados, donde se conoce el verdadero proceso que gobierna la serie de tiempo, estos valores pueden compararse con los valores obtenidos.

\subsubsection{Datos simulados}

```{r}
coeficientes_originales <- list(
    data.frame(
        tipo="Original",
        proceso = "ARIMA(1,0,0)",
        referencia="ARIMA(1,0,0)",
        coeficiente = names(comparacion_no_estacional_bajo[[1]]$modelos$original$coef),
        estimacion = comparacion_no_estacional_bajo[[1]]$modelos$original$coef,
        LI=NA,
        LS=NA
    ),
    data.frame(
        tipo="Original",
        proceso = "ARIMA(1,0,1)",
        referencia="ARIMA(1,0,1)",
        coeficiente = names(comparacion_no_estacional_bajo[[2]]$modelos$original$coef),
        estimacion = comparacion_no_estacional_bajo[[2]]$modelos$original$coef,
        LI=NA,
        LS=NA
    ),
    data.frame(
        tipo="Original",
        proceso = "ARIMA(2,0,3)",
        referencia="ARIMA(2,0,3)",
        coeficiente = names(comparacion_no_estacional_alto[[1]]$modelos$original$coef),
        estimacion = comparacion_no_estacional_alto[[1]]$modelos$original$coef,
        LI=NA,
        LS=NA
    ),
    data.frame(
        tipo="Original",
        proceso = "ARIMA(4,0,2)",
        referencia="ARIMA(4,0,2)",
        coeficiente = names(comparacion_no_estacional_alto[[2]]$modelos$original$coef),
        estimacion = comparacion_no_estacional_alto[[2]]$modelos$original$coef,
        LI=NA,
        LS=NA
    ),
    data.frame(
        tipo="Original",
        proceso = "ARIMA(0,0,1)(0,1,1)",
        referencia="ARIMA(0,0,1)(0,1,1)",
        coeficiente = names(comparacion_estacional_bajo[[1]]$modelos$original$coef),
        estimacion = comparacion_estacional_bajo[[1]]$modelos$original$coef,
        LI=NA,
        LS=NA
    ),
    data.frame(
        tipo="Original",
        proceso = "ARIMA(2,1,4)(3,0,3)",
        referencia="ARIMA(2,1,4)(3,0,3)",
        coeficiente = names(comparacion_estacional_alto[[2]]$modelos$original$coef),
        estimacion = comparacion_estacional_alto[[2]]$modelos$original$coef,
        LI=NA,
        LS=NA
    )
) %>% do.call(rbind, .)

##############################################

coeficientes_auto.arima <- list(
    data.frame(
        tipo="auto.arima()",
        proceso = "ARIMA(2,1,1)",
        referencia="ARIMA(1,0,0)",
        coeficiente = names(comparacion_no_estacional_bajo[[1]]$modelos$autoarima$coef),
        estimacion = comparacion_no_estacional_bajo[[1]]$modelos$autoarima$coef,
        LI=confint(comparacion_no_estacional_bajo[[1]]$modelos$autoarima)[,1],
        LS=confint(comparacion_no_estacional_bajo[[1]]$modelos$autoarima)[,2]
    ),
    data.frame(
        tipo="auto.arima()",
        proceso = "ARIMA(0,1,1)",
        referencia="ARIMA(1,0,1)",
        coeficiente = names(comparacion_no_estacional_bajo[[2]]$modelos$autoarima$coef),
        estimacion = comparacion_no_estacional_bajo[[2]]$modelos$autoarima$coef,
        LI=confint(comparacion_no_estacional_bajo[[2]]$modelos$autoarima)[,1],
        LS=confint(comparacion_no_estacional_bajo[[2]]$modelos$autoarima)[,2]
    ),
    data.frame(
        tipo="auto.arima()",
        proceso = "ARIMA(1,0,3)",
        referencia="ARIMA(2,0,3)",
        coeficiente = names(comparacion_no_estacional_alto[[1]]$modelos$autoarima$coef),
        estimacion = comparacion_no_estacional_alto[[1]]$modelos$autoarima$coef,
        LI=confint(comparacion_no_estacional_alto[[1]]$modelos$autoarima)[,1],
        LS=confint(comparacion_no_estacional_alto[[1]]$modelos$autoarima)[,2]
    ),
    data.frame(
        tipo="auto.arima()",
        proceso = "ARIMA(1,1,3)",
        referencia="ARIMA(4,0,2)",
        coeficiente = names(comparacion_no_estacional_alto[[2]]$modelos$autoarima$coef),
        estimacion = comparacion_no_estacional_alto[[2]]$modelos$autoarima$coef,
        LI=confint(comparacion_no_estacional_alto[[2]]$modelos$autoarima)[,1],
        LS=confint(comparacion_no_estacional_alto[[2]]$modelos$autoarima)[,2]
    ),
    data.frame(
        tipo="auto.arima()",
        proceso = "ARIMA(0,0,1)(0,1,1)",
        referencia="ARIMA(0,0,1)(0,1,1)",
        coeficiente = names(comparacion_estacional_bajo[[1]]$modelos$autoarima$coef),
        estimacion = comparacion_estacional_bajo[[1]]$modelos$autoarima$coef,
        LI=confint(comparacion_estacional_bajo[[1]]$modelos$autoarima)[,1],
        LS=confint(comparacion_estacional_bajo[[1]]$modelos$autoarima)[,2]
    ),
    data.frame(
        tipo="auto.arima()",
        proceso = "ARIMA(1,1,2)(2,1,1)",
        referencia="ARIMA(2,1,4)(3,0,3)",
        coeficiente = names(comparacion_estacional_alto[[2]]$modelos$autoarima$coef),
        estimacion = comparacion_estacional_alto[[2]]$modelos$autoarima$coef,
        LI=confint(comparacion_estacional_alto[[2]]$modelos$autoarima)[,1],
        LS=confint(comparacion_estacional_alto[[2]]$modelos$autoarima)[,2]
    )
) %>% do.call(rbind, .)

##############################################
coeficientes_sobreparametrizacion <- list(
    data.frame(
        tipo="Sobreparametrización",
        proceso = "ARIMA(1,0,0)",
        referencia="ARIMA(1,0,0)",
        coeficiente = names(comparacion_no_estacional_bajo[[1]]$modelos$sobreparametrizacion$coef),
        estimacion = comparacion_no_estacional_bajo[[1]]$modelos$sobreparametrizacion$coef,
        LI=confint(comparacion_no_estacional_bajo[[1]]$modelos$sobreparametrizacion)[,1],
        LS=confint(comparacion_no_estacional_bajo[[1]]$modelos$sobreparametrizacion)[,2]
    ),
    data.frame(
        tipo="Sobreparametrización",
        proceso = "ARIMA(0,1,1)",
        referencia="ARIMA(1,0,1)",
        coeficiente = names(comparacion_no_estacional_bajo[[2]]$modelos$sobreparametrizacion$coef),
        estimacion = comparacion_no_estacional_bajo[[2]]$modelos$sobreparametrizacion$coef,
        LI=confint(comparacion_no_estacional_bajo[[2]]$modelos$sobreparametrizacion)[,1],
        LS=confint(comparacion_no_estacional_bajo[[2]]$modelos$sobreparametrizacion)[,2]
    ),
    data.frame(
        tipo="Sobreparametrización",
        proceso = "ARIMA(0,0,5)",
        referencia="ARIMA(2,0,3)",
        coeficiente = names(comparacion_no_estacional_alto[[1]]$modelos$sobreparametrizacion$coef),
        estimacion = comparacion_no_estacional_alto[[1]]$modelos$sobreparametrizacion$coef,
        LI=confint(comparacion_no_estacional_alto[[1]]$modelos$sobreparametrizacion)[,1],
        LS=confint(comparacion_no_estacional_alto[[1]]$modelos$sobreparametrizacion)[,2]
    ),
    data.frame(
        tipo="Sobreparametrización",
        proceso = "ARIMA(1,1,0)",
        referencia="ARIMA(4,0,2)",
        coeficiente = names(comparacion_no_estacional_alto[[2]]$modelos$sobreparametrizacion$coef),
        estimacion = comparacion_no_estacional_alto[[2]]$modelos$sobreparametrizacion$coef,
        LI=confint(comparacion_no_estacional_alto[[2]]$modelos$sobreparametrizacion)[,1],
        LS=confint(comparacion_no_estacional_alto[[2]]$modelos$sobreparametrizacion)[,2]
    ),
    data.frame(
        tipo="Sobreparametrización",
        proceso = "ARIMA(0,0,1)(0,1,1)",
        referencia="ARIMA(0,0,1)(0,1,1)",
        coeficiente = names(comparacion_estacional_bajo[[1]]$modelos$sobreparametrizacion$coef),
        estimacion = comparacion_estacional_bajo[[1]]$modelos$sobreparametrizacion$coef,
        LI=confint(comparacion_estacional_bajo[[1]]$modelos$sobreparametrizacion)[,1],
        LS=confint(comparacion_estacional_bajo[[1]]$modelos$sobreparametrizacion)[,2]
    ),
    data.frame(
        tipo="Sobreparametrización",
        proceso = "ARIMA(1,1,2)(2,1,2)",
        referencia="ARIMA(2,1,4)(3,0,3)",
        coeficiente = names(comparacion_estacional_alto[[2]]$modelos$sobreparametrizacion$coef),
        estimacion = comparacion_estacional_alto[[2]]$modelos$sobreparametrizacion$coef,
        LI=confint(comparacion_estacional_alto[[2]]$modelos$sobreparametrizacion)[,1],
        LS=confint(comparacion_estacional_alto[[2]]$modelos$sobreparametrizacion)[,2]
    )
) %>% do.call(rbind, .)
###################################

coeficientes_arima_estandar <- list(
    data.frame(
        tipo="ARIMA estándar",
        proceso = "ARIMA(1,1,1)",
        referencia="ARIMA(1,0,0)",
        coeficiente = names(comparacion_no_estacional_bajo[[1]]$modelos$arima_estandar$coef),
        estimacion = comparacion_no_estacional_bajo[[1]]$modelos$arima_estandar$coef,
        LI=confint(comparacion_no_estacional_bajo[[1]]$modelos$arima_estandar)[,1],
        LS=confint(comparacion_no_estacional_bajo[[1]]$modelos$arima_estandar)[,2]
    ),
    data.frame(
        tipo="ARIMA estándar",
        proceso = "ARIMA(1,1,1)",
        referencia="ARIMA(1,0,1)",
        coeficiente = names(comparacion_no_estacional_bajo[[2]]$modelos$arima_estandar$coef),
        estimacion = comparacion_no_estacional_bajo[[2]]$modelos$arima_estandar$coef,
        LI=confint(comparacion_no_estacional_bajo[[2]]$modelos$arima_estandar)[,1],
        LS=confint(comparacion_no_estacional_bajo[[2]]$modelos$arima_estandar)[,2]
    ),
    data.frame(
        tipo="ARIMA estándar",
       proceso = "ARIMA(1,1,1)",
       referencia="ARIMA(2,0,3)",
        coeficiente = names(comparacion_no_estacional_alto[[1]]$modelos$arima_estandar$coef),
        estimacion = comparacion_no_estacional_alto[[1]]$modelos$arima_estandar$coef,
        LI=confint(comparacion_no_estacional_alto[[1]]$modelos$arima_estandar)[,1],
        LS=confint(comparacion_no_estacional_alto[[1]]$modelos$arima_estandar)[,2]
    ),
    data.frame(
        tipo="ARIMA estándar",
        proceso = "ARIMA(1,1,1)",
        referencia="ARIMA(4,0,2)",
        coeficiente = names(comparacion_no_estacional_alto[[2]]$modelos$arima_estandar$coef),
        estimacion = comparacion_no_estacional_alto[[2]]$modelos$arima_estandar$coef,
        LI=confint(comparacion_no_estacional_alto[[2]]$modelos$arima_estandar)[,1],
        LS=confint(comparacion_no_estacional_alto[[2]]$modelos$arima_estandar)[,2]
    ),
    data.frame(
        tipo="ARIMA estándar",
        proceso = "ARIMA(1,1,1)(1,1,1)",
        referencia="ARIMA(0,0,1)(0,1,1)",
        coeficiente = names(comparacion_estacional_bajo[[1]]$modelos$arima_estandar$coef),
        estimacion = comparacion_estacional_bajo[[1]]$modelos$arima_estandar$coef,
        LI=confint(comparacion_estacional_bajo[[1]]$modelos$arima_estandar)[,1],
        LS=confint(comparacion_estacional_bajo[[1]]$modelos$arima_estandar)[,2]
    ),
    data.frame(
        tipo="ARIMA estándar",
        proceso = "ARIMA(1,1,1)(1,1,1)",
        referencia="ARIMA(2,1,4)(3,0,3)",
        coeficiente = names(comparacion_estacional_alto[[2]]$modelos$arima_estandar$coef),
        estimacion = comparacion_estacional_alto[[2]]$modelos$arima_estandar$coef,
        LI=confint(comparacion_estacional_alto[[2]]$modelos$arima_estandar)[,1],
        LS=confint(comparacion_estacional_alto[[2]]$modelos$arima_estandar)[,2]
    )
) %>% do.call(rbind, .)
```

El cuadro \ref{tab:coeficientes_original_autoarima} resume los resultados obtenidos en la estimación de los coeficientes. En la columna *Proceso original* se indica el proceso a partir del cual se generó la serie cronológica mediante simulación, en la columna *Coeficiente* se indica el coeficiente al cual pertenecen las estimaciones presentes en las columnas *Valor real* (el valor del coeficiente del proceso original), *Estimación auto.arima()* (valor estimado del coeficiente mediante la función `auto.arima()`), *Límite Inferior* y *Límite Superior* del intervalo de confianza el 95% para los coeficientes estimados en la columna *Estimación auto.arima()*. Como se ha mencionado, la notación más utilizada para los modelos $ARIMA$ es $ARIMA(p,d,q)(P,D,Q)$, que en la columna *Coeficiente* equivale a $ARIMA(ARX, d, MAX)(SARX, D, SMAX)$, con $X=\{1,2,3,4\}$, según corresponda.

De esta manera, a modo de ejemplo, para los datos simulados a partir de un $ARIMA(4,0,2)$, los coeficientes de $AR1$ hasta $AR4$ representan los cuatro coeficientes de la parte autorregresiva no estacional, mientras que $MA1$ y $MA2$ son los dos coeficientes del modelo de medias móviles de la parte no estacional, la celda del *Valor real* correspondiente al coeficiente $MA3$ está vacía porque el modelo original solo tenía dos coeficientes en el modelo de medias móviles, no tres. Así, el modelo estimado con `auto.arima()` estima únicamente los coeficientes $AR1$ y $AR2$ para el modelo autorregresivo, y $MA1$, $MA2$ y $MA3$ para el modelo de medias móviles.

```{r}
do.call(
    rbind,
    list(
        coeficientes_originales,
        coeficientes_auto.arima,
        coeficientes_sobreparametrizacion,
        coeficientes_arima_estandar
    )
) %>%
    data.frame(row.names = NULL) %>%
    filter(tipo %in% c("Original", "auto.arima()"),
           coeficiente != "intercept") %>%
    select(-proceso) %>%
    mutate(
        coeficiente = factor(
            toupper(coeficiente),
            levels = c(
                "INTERCEPT",
                paste0("AR", 1:6),
                paste0("MA", 1:6),
                paste0("SAR", 1:6),
                paste0("SMA", 1:6)
            ),
            ordered = T
        ),
        referencia = factor(
            referencia,
            levels = c(
                "ARIMA(1,0,0)",
                "ARIMA(1,0,1)",
                "ARIMA(2,0,3)",
                "ARIMA(4,0,2)",
                "ARIMA(0,0,1)(0,1,1)",
                "ARIMA(2,1,4)(3,0,3)"
            ),
            ordered = T
        )
    ) %>%
    pivot_wider(names_from = tipo,
                values_from = c(estimacion, LI, LS)) %>%
    arrange(referencia, coeficiente) %>%
    select(-c(LI_Original, LS_Original)) %>%
    mutate_if(is.numeric, function(x){
        case_when(
            x==0 ~ x+.1,
            TRUE ~ x
        )
    }) %>% 
    mutate_if(is.numeric, function(x) ifelse(is.na(x), "", as.character(round(x, 2)))) %>% 
    kbl(.,
        "latex",
        booktabs = T,
        escape = F, 
        align = "r",
        caption = "\\label{tab:coeficientes_original_autoarima}Coefcientes del proceso original y los estimados con auto.arima()",
        col.names = c(
            "Proceso original",
            "Coeficiente",
            "Valor real",
            "Estimación auto.arima()",
            "Límite Inferior",
            "Límite Superior"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 5
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>% 
    column_spec(1, bold = T, extra_css = 'center-align: top !important;')
```

\subsubsection{Datos reales}

En el caso de las series cronológicas reales, se toma en consideración el mejor modelo sugerido por la función `auto.arima()`. Los coeficientes obtenidos para las distintas series de tiempo costarricenses se muestran en el cuadro \ref{tab:coeficientes_reales_autoarima}.

```{r agregando_arima_estandar_a_series_reales, results='hide'}
# TMII$arima_estandar <- Arima(TMII$haa$x, order = c(1,1,1), seasonal = list(order=c(1,1,1)), method = "ML")
# EXTERNA$arima_estandar <- Arima(EXTERNA$haa$x, order = c(1,1,1), seasonal = list(order=c(1,1,1)), method = "ML")
# INCENTIVOS$arima_estandar <- Arima(INCENTIVOS$haa$x, order = c(1,1,1), seasonal = list(order=c(1,1,1)), method = "ML")
# INTERESES$arima_estandar <- Arima(INTERESES$haa$x, order = c(1,1,1), seasonal = list(order=c(1,1,1)), method = "ML")
```


```{r}
list(
    data.frame(
        Serie="TMII",
        coeficiente = names(TMII$haa$coef),
        estimacion = TMII$haa$coef,
        LI=confint(TMII$haa)[,1],
        LS=confint(TMII$haa)[,2]
    ),
    data.frame(
        Serie="Mortalidad por causa externa",
        coeficiente = names(EXTERNA$haa$coef),
        estimacion = EXTERNA$haa$coef,
        LI=confint(EXTERNA$haa)[,1],
        LS=confint(EXTERNA$haa)[,2]
    ),
    data.frame(
        Serie="Incentivos salariales",
        coeficiente = names(INCENTIVOS$haa$coef),
        estimacion = INCENTIVOS$haa$coef,
        LI=confint(INCENTIVOS$haa)[,1],
        LS=confint(INCENTIVOS$haa)[,2]
    ),
    data.frame(
        Serie="Intereses y comisiones",
        coeficiente = names(INTERESES$haa$coef),
        estimacion = INTERESES$haa$coef,
        LI=confint(INTERESES$haa)[,1],
        LS=confint(INTERESES$haa)[,2]
    )
) %>% 
    do.call(rbind, .) %>%
    data.frame(row.names = NULL) %>%
    filter(coeficiente != "drift") %>%
    mutate(
        coeficiente = factor(
            toupper(coeficiente),
            levels = c(
                paste0("AR", 1:6),
                paste0("MA", 1:6),
                paste0("SAR", 1:6),
                paste0("SMA", 1:6)
            ),
            ordered = T
        )
    ) %>%
    mutate_if(is.numeric, round, 2) %>% 
    kbl(.,
        "latex",
        booktabs = T,
        escape = F, 
        align = "r",
        caption = "\\label{tab:coeficientes_reales_autoarima}Coefcientes de los modelos ajustados con a las series reales con auto.arima()",
        col.names = c(
            "Serie",
            "Coeficiente",
            "Estimación",
            "Límite Inferior",
            "Límite Superior"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 5
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>% 
    column_spec(1, bold = T, extra_css = 'center-align: top !important;')
```

\subsection{Identificación y estimación del mejor modelo con sobreparametrización}

De manera análoga al procedimiento realizado con la función `auto.arima()`, se realiza el proceso descrito en la metodología para seleccionar el mejor modelo utilizando la sobreparametrización. Nuevamente, para los datos simulados, se conoce de previo el verdadero proceso que gobierna la serie de temporal, los cuales se comparan con los valores de los coeficientes de cada modelo obtenido mediante la sobreparametrización.

\subsubsection{Datos simulados}

Los mismos conceptos explicados para el cuadro \ref{tab:coeficientes_original_autoarima} aplican ahora para el \ref{tab:coeficientes_original_sobreparametrizacion}.

```{r}
do.call(
    rbind,
    list(
        coeficientes_originales,
        coeficientes_auto.arima,
        coeficientes_sobreparametrizacion,
        coeficientes_arima_estandar
    )
) %>%
    data.frame(row.names = NULL) %>%
    filter(tipo %in% c("Original", "Sobreparametrización"),
           coeficiente != "intercept") %>%
    select(-proceso) %>%
    mutate(
        coeficiente = factor(
            toupper(coeficiente),
            levels = c(
                "INTERCEPT",
                paste0("AR", 1:6),
                paste0("MA", 1:6),
                paste0("SAR", 1:6),
                paste0("SMA", 1:6)
            ),
            ordered = T
        ),
        referencia = factor(
            referencia,
            levels = c(
                "ARIMA(1,0,0)",
                "ARIMA(1,0,1)",
                "ARIMA(2,0,3)",
                "ARIMA(4,0,2)",
                "ARIMA(0,0,1)(0,1,1)",
                "ARIMA(2,1,4)(3,0,3)"
            ),
            ordered = T
        )
    ) %>%
    pivot_wider(names_from = tipo,
                values_from = c(estimacion, LI, LS)) %>%
    arrange(referencia, coeficiente) %>%
    select(-c(LI_Original, LS_Original)) %>%
    mutate_if(is.numeric, function(x){
        case_when(
            x==0 ~ x+.1,
            TRUE ~ x
        )
    }) %>% 
    mutate_if(is.numeric, function(x) ifelse(is.na(x), "", as.character(round(x, 2)))) %>% 
    kbl(.,
        "latex",
        booktabs = T,
        escape = F, 
        align = "r",
        caption = "\\label{tab:coeficientes_original_sobreparametrizacion}Coefcientes del proceso original y los estimados con sobreparametrización",
        col.names = c(
            "Proceso original",
            "Coeficiente",
            "Valor real",
            "Estimación sobreparametrización",
            "Límite Inferior",
            "Límite Superior"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 5
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>% 
    column_spec(1, bold = T, extra_css = 'center-align: top !important;')
```

\subsubsection{Datos reales}

Para las series cronológicas reales también se toma en consideración el mejor modelo sugerido esta vez por la sobreparametrización. Los coeficientes obtenidos para las distintas series de tiempo costarricenses se muestran en el cuadro \ref{tab:coeficientes_reales_sobreparametrizacion}.

```{r}
list(
    data.frame(
        Serie="TMII",
        coeficiente = names(TMII$op$best_model$coef),
        estimacion = TMII$op$best_model$coef,
        LI=confint(TMII$op$best_model)[,1],
        LS=confint(TMII$op$best_model)[,2]
    ),
    data.frame(
        Serie="Mortalidad por causa externa",
        coeficiente = names(EXTERNA$op$best_model$coef),
        estimacion = EXTERNA$op$best_model$coef,
        LI=confint(EXTERNA$op$best_model)[,1],
        LS=confint(EXTERNA$op$best_model)[,2]
    ),
    data.frame(
        Serie="Incentivos salariales",
        coeficiente = names(INCENTIVOS$op$best_model$coef),
        estimacion = INCENTIVOS$op$best_model$coef,
        LI=confint(INCENTIVOS$op$best_model)[,1],
        LS=confint(INCENTIVOS$op$best_model)[,2]
    ),
    data.frame(
        Serie="Intereses y comisiones",
        coeficiente = names(INTERESES$op$best_model$coef),
        estimacion = INTERESES$op$best_model$coef,
        LI=confint(INTERESES$op$best_model)[,1],
        LS=confint(INTERESES$op$best_model)[,2]
    )
) %>% 
    do.call(rbind, .) %>%
    data.frame(row.names = NULL) %>%
    filter(coeficiente != "drift") %>%
    mutate(
        coeficiente = factor(
            toupper(coeficiente),
            levels = c(
                paste0("AR", 1:6),
                paste0("MA", 1:6),
                paste0("SAR", 1:6),
                paste0("SMA", 1:6)
            ),
            ordered = T
        )
    ) %>%
    mutate_if(is.numeric, round, 2) %>% 
    kbl(.,
        "latex",
        booktabs = T,
        escape = F, 
        align = "r",
        caption = "\\label{tab:coeficientes_reales_sobreparametrizacion}Coefcientes de los modelos ajustados con a las series reales con sobreparametrización",
        col.names = c(
            "Serie",
            "Coeficiente",
            "Estimación",
            "Límite Inferior",
            "Límite Superior"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 5
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>% 
    column_spec(1, bold = T, extra_css = 'center-align: top !important;')
```

\subsection{Estimación de un modelo ARIMA estándar}

Ajustar un modelo ARIMA genérico sirve para referenciar los demás resultados obtenidos, es decir, contrastarlos con los resultados del `auto.arima()` y la sobreparametrización. Nuevamente, para los datos simulados se comparan los coeficientes obtenidos con los que se connocen a priori.

\subsubsection{Datos simulados}

Los mismos conceptos explicados para los cuadros \ref{tab:coeficientes_original_autoarima} y \ref{tab:coeficientes_original_sobreparametrizacion} aplican ahora para el cuadro \ref{tab:coeficientes_original_arima_estandar}.

```{r}
do.call(
    rbind,
    list(
        coeficientes_originales,
        coeficientes_auto.arima,
        coeficientes_sobreparametrizacion,
        coeficientes_arima_estandar
    )
) %>%
    data.frame(row.names = NULL) %>%
    filter(tipo %in% c("Original", "ARIMA estándar"),
           coeficiente != "intercept") %>%
    select(-proceso) %>%
    mutate(
        coeficiente = factor(
            toupper(coeficiente),
            levels = c(
                "INTERCEPT",
                paste0("AR", 1:6),
                paste0("MA", 1:6),
                paste0("SAR", 1:6),
                paste0("SMA", 1:6)
            ),
            ordered = T
        ),
        referencia = factor(
            referencia,
            levels = c(
                "ARIMA(1,0,0)",
                "ARIMA(1,0,1)",
                "ARIMA(2,0,3)",
                "ARIMA(4,0,2)",
                "ARIMA(0,0,1)(0,1,1)",
                "ARIMA(2,1,4)(3,0,3)"
            ),
            ordered = T
        )
    ) %>%
    pivot_wider(names_from = tipo,
                values_from = c(estimacion, LI, LS)) %>%
    arrange(referencia, coeficiente) %>%
    select(-c(LI_Original, LS_Original)) %>%
    mutate_if(is.numeric, function(x){
        case_when(
            x==0 ~ x+.1,
            TRUE ~ x
        )
    }) %>% 
    mutate_if(is.numeric, function(x) ifelse(is.na(x), "", as.character(round(x, 2)))) %>% 
    kbl(.,
        "latex",
        booktabs = T,
        escape = F, 
        align = "r",
        caption = "\\label{tab:coeficientes_original_arima_estandar}Coefcientes del proceso original y los estimados con un ARIMA estándar",
        col.names = c(
            "Proceso original",
            "Coeficiente",
            "Valor real",
            "Estimación ARIMA estándar",
            "Límite Inferior",
            "Límite Superior"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 5
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>% 
    column_spec(1, bold = T, extra_css = 'center-align: top !important;')
```

\subsubsection{Datos reales}

Las series cronológicas reales, al contar con un componente estacional, se ajustan todas con un $ARIMA(1,1,1)(1,1,1)$. Los resultados aparecen en el cuadro \ref{tab:coeficientes_reales_arima_estandar}.

```{r}
list(
    data.frame(
        Serie="TMII",
        coeficiente = names(TMII$arima_estandar$coef),
        estimacion = TMII$arima_estandar$coef,
        LI=confint(TMII$arima_estandar)[,1],
        LS=confint(TMII$arima_estandar)[,2]
    ),
    data.frame(
        Serie="Mortalidad por causa externa",
        coeficiente = names(EXTERNA$arima_estandar$coef),
        estimacion = EXTERNA$arima_estandar$coef,
        LI=confint(EXTERNA$arima_estandar)[,1],
        LS=confint(EXTERNA$arima_estandar)[,2]
    ),
    data.frame(
        Serie="Incentivos salariales",
        coeficiente = names(INCENTIVOS$arima_estandar$coef),
        estimacion = INCENTIVOS$arima_estandar$coef,
        LI=confint(INCENTIVOS$arima_estandar)[,1],
        LS=confint(INCENTIVOS$arima_estandar)[,2]
    ),
    data.frame(
        Serie="Intereses y comisiones",
        coeficiente = names(INTERESES$arima_estandar$coef),
        estimacion = INTERESES$arima_estandar$coef,
        LI=confint(INTERESES$arima_estandar)[,1],
        LS=confint(INTERESES$arima_estandar)[,2]
    )
) %>% 
    do.call(rbind, .) %>%
    data.frame(row.names = NULL) %>%
    filter(coeficiente != "drift") %>%
    mutate(
        coeficiente = factor(
            toupper(coeficiente),
            levels = c(
                paste0("AR", 1:6),
                paste0("MA", 1:6),
                paste0("SAR", 1:6),
                paste0("SMA", 1:6)
            ),
            ordered = T
        )
    ) %>%
    mutate_if(is.numeric, round, 2) %>% 
    kbl(.,
        "latex",
        booktabs = T,
        escape = F, 
        align = "r",
        caption = "\\label{tab:coeficientes_reales_arima_estandar}Coefcientes de los modelos ajustados con a las series reales con un ARIMA estándar",
        col.names = c(
            "Serie",
            "Coeficiente",
            "Estimación",
            "Límite Inferior",
            "Límite Superior"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 5
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>% 
    column_spec(1, bold = T, extra_css = 'center-align: top !important;')
```

\subsection{Análisis de los errores}

Al ver el comportamiento de los errores buscamos que estos se comporten como ruido blanco, es decir, que no tengan ningún patrón en particular. El autocorrelograma de los residuos también puede usarse para este fin, pues el 95% de los valores debería estar entre las dos líneas azules. Además, un histograma de los residuos es útil para saber si los residuos siguen una distribución aproximadamente Normal; si no existen grandes desviaciones en este gráfico, entonces puede decirse que el cumplimiento de este supuesto es razonable.

```{r}
analisis_errores <- function(modelo, titulo="") {
    residuos <- residuals(modelo)
    
    g1 <- autoplot(residuos) +
        xlab("Periodos") +
        ylab("Residuos")
    
    g2 <- ggAcf(residuos, xlab = "Rezagos", main = "")
    
    g3 <- gghistogram(residuos, add.normal = T) +
        xlab("Residuos") +
        ylab("Conteo")

    annotate_figure(
        ggarrange(
            g1,
            ggarrange(g2, g3, ncol = 2, nrow = 1),
            ncol = 1,
            nrow = 2
        ),
        top = text_grob(
            titulo,
            color = "black",
            face = "bold",
            size = 14
        )
    )
}
```


\subsubsection{Datos simulados}

Al estimar modelos mediante la función `auto.arima()`, la sobreparametrización y el $ARIMA$ estándar, es necesario analizar el comportamiento de los errores para los seis modelos estimados con cada técnica.

\paragraph{Errores de los modelos estimados con auto.arima()}

Las visualizaciones de los errores de los modelos estimados con la función `auto.arima()` se muestran en las figuras \ref{fig:errores_simulados_autoarima1}, \ref{fig:errores_simulados_autoarima2}, \ref{fig:errores_simulados_autoarima3}, \ref{fig:errores_simulados_autoarima4}, \ref{fig:errores_simulados_autoarima5} y \ref{fig:errores_simulados_autoarima6}. En general, los modelos poseen el comportamiento esperado, aunque cuando se incorporan componentes estacionales los errores varían un poco más en los autocorelogramas y el supuesto de normalidad.

```{r}
errores_simulados_autoarima1 <- analisis_errores(comparacion_no_estacional_bajo[[1]]$modelos$autoarima,"")
errores_simulados_autoarima2<- analisis_errores(comparacion_no_estacional_bajo[[2]]$modelos$autoarima,"")
errores_simulados_autoarima3<- analisis_errores(comparacion_no_estacional_alto[[1]]$modelos$autoarima,"")
errores_simulados_autoarima4<- analisis_errores(comparacion_no_estacional_alto[[2]]$modelos$autoarima,"")
errores_simulados_autoarima5<- analisis_errores(comparacion_estacional_bajo[[1]]$modelos$autoarima,"")
errores_simulados_autoarima6<- analisis_errores(comparacion_estacional_alto[[2]]$modelos$autoarima,"")
```

```{r errores_simulados_autoarima1, fig.cap="Comportamiento de los errores del modelo ARIMA(0,1,1) estimado con auto.arima() para los datos generados con un ARIMA(1,0,0)"}
errores_simulados_autoarima1
```

```{r errores_simulados_autoarima2, fig.cap="Comportamiento de los errores del modelo ARIMA(0,0,1) estimado con auto.arima() para los datos generados con un ARIMA(1,0,1)"}
errores_simulados_autoarima2
```

```{r errores_simulados_autoarima3, fig.cap="Comportamiento de los errores del modelo ARIMA(1,0,3) estimado con auto.arima() para los datos generados con un ARIMA(2,0,3)"}
errores_simulados_autoarima3
```

```{r errores_simulados_autoarima4, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,3) estimado con auto.arima() para los datos generados con un ARIMA(4,0,2)"}
errores_simulados_autoarima4
```

```{r errores_simulados_autoarima5, fig.cap="Comportamiento de los errores del modelo ARIMA(0,0,1)(0,1,1) estimado con auto.arima() para los datos generados con un ARIMA(0,0,1)(0,1,1)"}
errores_simulados_autoarima5
```

```{r errores_simulados_autoarima6, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,2)(2,1,1) estimado con auto.arima() para los datos generados con un ARIMA(2,1,4)(3,0,3)"}
errores_simulados_autoarima6
```

\paragraph{Errores de los modelos estimados con sobreparametrización}

Las visualizaciones de los errores de los modelos estimados con sobreparametrización se muestran en las figuras \ref{fig:errores_simulados_sobreparametrizacion1}, \ref{fig:errores_simulados_sobreparametrizacion2}, \ref{fig:errores_simulados_sobreparametrizacion3}, \ref{fig:errores_simulados_sobreparametrizacion4}, \ref{fig:errores_simulados_sobreparametrizacion5} y \ref{fig:errores_simulados_sobreparametrizacion6}. En general, los modelos poseen el comportamiento esperado, incluso con menos problemas en la parte estacional.

```{r}
errores_simulados_sobreparametrizacion1 <- analisis_errores(comparacion_no_estacional_bajo[[1]]$modelos$sobreparametrizacion,"")
errores_simulados_sobreparametrizacion2<- analisis_errores(comparacion_no_estacional_bajo[[2]]$modelos$sobreparametrizacion,"")
errores_simulados_sobreparametrizacion3<- analisis_errores(comparacion_no_estacional_alto[[1]]$modelos$sobreparametrizacion,"")
errores_simulados_sobreparametrizacion4<- analisis_errores(comparacion_no_estacional_alto[[2]]$modelos$sobreparametrizacion,"")
errores_simulados_sobreparametrizacion5<- analisis_errores(comparacion_estacional_bajo[[1]]$modelos$sobreparametrizacion,"")
errores_simulados_sobreparametrizacion6<- analisis_errores(comparacion_estacional_alto[[2]]$modelos$sobreparametrizacion,"")
```

```{r errores_simulados_sobreparametrizacion1, fig.cap="Comportamiento de los errores del modelo ARIMA(1,0,0) estimado con sobreparametrización para los datos generados con un ARIMA(1,0,0)"}
errores_simulados_sobreparametrizacion1
```

```{r errores_simulados_sobreparametrizacion2, fig.cap="Comportamiento de los errores del modelo ARIMA(0,1,1) estimado con sobreparametrización para los datos generados con un ARIMA(1,0,1)"}
errores_simulados_sobreparametrizacion2
```

```{r errores_simulados_sobreparametrizacion3, fig.cap="Comportamiento de los errores del modelo ARIMA(0,0,5) estimado con sobreparametrización para los datos generados con un ARIMA(2,0,3)"}
errores_simulados_sobreparametrizacion3
```

```{r errores_simulados_sobreparametrizacion4, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,0) estimado con sobreparametrización para los datos generados con un ARIMA(4,0,2)"}
errores_simulados_sobreparametrizacion4
```

```{r errores_simulados_sobreparametrizacion5, fig.cap="Comportamiento de los errores del modelo ARIMA(0,0,1)(0,1,1) estimado con sobreparametrización para los datos generados con un ARIMA(0,0,1)(0,1,1)"}
errores_simulados_sobreparametrizacion5
```

```{r errores_simulados_sobreparametrizacion6, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,2)(2,1,2) estimado con sobreparametrización para los datos generados con un ARIMA(2,1,4)(3,0,3)"}
errores_simulados_sobreparametrizacion6
```

\paragraph{Errores de los modelos estimados con un modelo ARIMA estándar}

Como ya fue mencionado, para los modelos sin parte estacional se ajustó un modelo $ARIMA(1,1,1)$, mientras que para las series simuladas estacionales se ajustaron modelos $ARIMA(1,1,1)(1,1,1)$. Las visualizaciones de los residuos se muestran en las figuras \ref{fig:errores_simulados_arima_estandar1}, \ref{fig:errores_simulados_arima_estandar2}, \ref{fig:errores_simulados_arima_estandar3}, \ref{fig:errores_simulados_arima_estandar4}, \ref{fig:errores_simulados_arima_estandar5} y \ref{fig:errores_simulados_arima_estandar6}. Este tipo de moelos son los que presentan una mayor cantidad de inconvenientes, particularmente en los autocorelogramas, donde varios modelos se salen de los márgenes.

```{r}
errores_simulados_arima_estandar1 <- analisis_errores(comparacion_no_estacional_bajo[[1]]$modelos$arima_estandar,"")
errores_simulados_arima_estandar2<- analisis_errores(comparacion_no_estacional_bajo[[2]]$modelos$arima_estandar,"")
errores_simulados_arima_estandar3<- analisis_errores(comparacion_no_estacional_alto[[1]]$modelos$arima_estandar,"")
errores_simulados_arima_estandar4<- analisis_errores(comparacion_no_estacional_alto[[2]]$modelos$arima_estandar,"")
errores_simulados_arima_estandar5<- analisis_errores(comparacion_estacional_bajo[[1]]$modelos$arima_estandar,"")
errores_simulados_arima_estandar6<- analisis_errores(comparacion_estacional_alto[[2]]$modelos$arima_estandar,"")
```

```{r errores_simulados_arima_estandar1, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1) estimado con los datos generados con un ARIMA(1,0,0)"}
errores_simulados_arima_estandar1
```

```{r errores_simulados_arima_estandar2, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1) estimado con los datos generados con un ARIMA(1,0,1)"}
errores_simulados_arima_estandar2
```

```{r errores_simulados_arima_estandar3, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1) estimado con los datos generados con un ARIMA(2,0,3)"}
errores_simulados_arima_estandar3
```

```{r errores_simulados_arima_estandar4, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1) estimado con los datos generados con un ARIMA(4,0,2)"}
errores_simulados_arima_estandar4
```

```{r errores_simulados_arima_estandar5, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1)(1,1,1) estimado con los datos generados con un ARIMA(0,0,1)(0,1,1)"}
errores_simulados_arima_estandar5
```

```{r errores_simulados_arima_estandar6, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1)(1,1,1) estimado con los datos generados con un ARIMA(2,1,4)(3,0,3)"}
errores_simulados_arima_estandar6
```

\subsubsection{Datos reales}


\paragraph{Errores de los modelos estimados con auto.arima()}

Las visualizaciones de los errores de los modelos estimados con la función `auto.arima()` para las series reales se muestran en las figuras \ref{fig:errores_reales_autoarima1}, \ref{fig:errores_reales_autoarima2}, \ref{fig:errores_reales_autoarima3}, \ref{fig:errores_reales_autoarima4}. Los mejores resultados se obtienen al modelar la tasa de mortalidad infantil interanual y la tasa de mortalidad por causa externa, más no en lo otros dos casos.

```{r}
errores_reales_autoarima1 <- analisis_errores(TMII$haa,"")
errores_reales_autoarima2<- analisis_errores(EXTERNA$haa, "")
errores_reales_autoarima3<- analisis_errores(INCENTIVOS$haa,"")
errores_reales_autoarima4<- analisis_errores(INTERESES$haa,"")
```

```{r errores_reales_autoarima1, fig.cap="Comportamiento de los errores del modelo ARIMA(2,1,0)(0,0,1) estimado con auto.arima() para la tasa de mortalidad infantl interanual"}
errores_reales_autoarima1
```

```{r errores_reales_autoarima2, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1) estimado con auto.arima() para la tasa de mortalidad por causa externa"}
errores_reales_autoarima2
```

```{r errores_reales_autoarima3, fig.cap="Comportamiento de los errores del modelo ARIMA(0,0,1)(1,1,0) estimado con auto.arima() para los incentivos salariales"}
errores_reales_autoarima3
```

```{r errores_reales_autoarima4, fig.cap="Comportamiento de los errores del modelo ARIMA(0,0,1)(0,1,0) estimado con auto.arima() para los intereses y comisiones del sector público"}
errores_reales_autoarima4
```

\paragraph{Errores de los modelos estimados con sobreparametrización}

Las visualizaciones de los errores de los modelos estimados mediante sobreparametrización para las series reales se muestran en las figuras \ref{fig:errores_reales_sobreparametrizacion1}, \ref{fig:errores_reales_sobreparametrizacion2}, \ref{fig:errores_reales_sobreparametrizacion3}, \ref{fig:errores_reales_sobreparametrizacion4}. Los mejores resultados se obtienen también al modelar la tasa de mortalidad infantil interanual y la tasa de mortalidad por causa externa, pues en las series temporales de incentivos salariales y de intereses y comisiones del sector público, algunos valores se salen de rango.

```{r}
errores_reales_sobreparametrizacion1 <- analisis_errores(TMII$op$best_model,"")
errores_reales_sobreparametrizacion2<- analisis_errores(EXTERNA$op$best_model, "")
errores_reales_sobreparametrizacion3<- analisis_errores(INCENTIVOS$op$best_model,"")
errores_reales_sobreparametrizacion4<- analisis_errores(INTERESES$op$best_model,"")
```

```{r errores_reales_sobreparametrizacion1, fig.cap="Comportamiento de los errores del modelo ARIMA(4,1,0)(4,1,0) estimado con sobreparametrización para la tasa de mortalidad infantl interanual"}
errores_reales_sobreparametrizacion1
```

```{r errores_reales_sobreparametrizacion2, fig.cap="Comportamiento de los errores del modelo ARIMA(2,0,1)(0,1,1) estimado con sobreparametrización para la tasa de mortalidad por causa externa"}
errores_reales_sobreparametrizacion2
```

```{r errores_reales_sobreparametrizacion3, fig.cap="Comportamiento de los errores del modelo ARIMA(2,1,0)(1,2,0) estimado con sobreparametrización para los incentivos salariales"}
errores_reales_sobreparametrizacion3
```

```{r errores_reales_sobreparametrizacion4, fig.cap="Comportamiento de los errores del modelo ARIMA(0,1,2)(0,1,0) estimado con sobreparametrización para los intereses y comisiones del sector público"}
errores_reales_sobreparametrizacion4
```

\paragraph{Errores de los modelos estimados con un modelo ARIMA estándar}

Las visualizaciones de los errores de los modelos estimados mediante mdelos $ARIMA(1,1,1)(1,1,1)$ para las series reales se muestran en las figuras \ref{fig:errores_reales_arima_estandar1}, \ref{fig:errores_reales_arima_estandar2}, \ref{fig:errores_reales_arima_estandar3}, \ref{fig:errores_reales_arima_estandar4}. De manera muy similar a los casos anteriores, los mejores resultados se obtienen también al modelar la tasa de mortalidad infantil interanual y la tasa de mortalidad por causa externa, mientras que en las series temporales de incentivos salariales y de intereses y comisiones del sector público, algunos valores se salen de rango.

```{r}
errores_reales_arima_estandar1 <- analisis_errores(TMII$arima_estandar,"")
errores_reales_arima_estandar2<- analisis_errores(EXTERNA$arima_estandar, "")
errores_reales_arima_estandar3<- analisis_errores(INCENTIVOS$arima_estandar,"")
errores_reales_arima_estandar4<- analisis_errores(INTERESES$arima_estandar,"")
```

```{r errores_reales_arima_estandar1, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1)(1,1,1) para la tasa de mortalidad infantl interanual"}
errores_reales_arima_estandar1
```

```{r errores_reales_arima_estandar2, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1)(1,1,1) para la tasa de mortalidad por causa externa"}
errores_reales_arima_estandar2
```

```{r errores_reales_arima_estandar3, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1)(1,1,1) para los incentivos salariales"}
errores_reales_arima_estandar3
```

```{r errores_reales_arima_estandar4, fig.cap="Comportamiento de los errores del modelo ARIMA(1,1,1)(1,1,1) para los intereses y comisiones del sector público"}
errores_reales_arima_estandar4
```

\subsection{Pronósticos}

Los pronósticos son parte fundamental del análisis de series cronológicas. En esta sección se realiza una inspección visual tanto para los datos simulados como para las series de tiempo de datos costarricenses. 

```{r funcion_resumen_resultados}
resumen_resultados <- function(x) {
    testing <- x$testing
    
    medidas_ajuste <- function(modelo) {
        resid <- modelo$residuals
        LL <-
            length(resid) * log(1) - length(resid) * log(sd(resid) * sqrt(2 * pi)) - (sum(resid ^ 2) / (2 * var(resid)))
        k <- length(modelo$coef) + 1
        n <- modelo$nobs
        AIC <- -2 * LL + 2 * (k)
        AICc <- -2 * LL + 2 * (k) + (2 * k + 1) / (n - k - 1)
        BIC <- -2 * LL + k * log(n)
        c(AIC = AIC,
          AICc = AICc,
          BIC = BIC)
    }
    
    resultados_reales <-
        lapply(list(x$haa, x$op$best_model, x$arima_estandar), function(x) {
            pronostico <- forecast(x, h = length(testing))$mean %>%
                c
            medidas <-
                accuracy(forecast(x, h = length(testing)), testing) %>%
                as.data.frame() %>%
                mutate(AIC = medidas_ajuste(x)[1],
                       AICc = medidas_ajuste(x)[2],
                       BIC = medidas_ajuste(x)[3])
            
            pronostico <-
                data.frame(pronostico = pronostico) %>% t %>%
                as.data.frame()
            
            list(pronostico = pronostico,
                 medidas = medidas)
        })
    
    
ajustados <- tryCatch({
    
        lapply(list(
            fitted(x$haa),
            fitted(x$op$best_model),
            fitted(x$arima_estandar),
            x$haa$x
        ), function(z) {
            inicio <- attributes(z)$tsp[1]
            z %>%
                as.data.frame() %>%
                mutate(
                    x = as.numeric(x),
                    fecha = seq(
                        as.Date(paste0(inicio, "-01-01")),
                        by = "month",
                        length.out = length(z)
                    )
                ) %>%
                select(valor = x, fecha)
        })
}, error=function(e){
    
        lapply(list(
            fitted(x$haa),
            fitted(x$op$best_model),
            fitted(x$arima_estandar),
            x$haa$x
        ), function(z) {
            inicio <- 1980
            z %>%
                as.data.frame() %>%
                mutate(
                    x = as.numeric(x),
                    fecha = seq(
                        as.Date(paste0(inicio, "-01-01")),
                        by = "month",
                        length.out = length(z)
                    )
                ) %>%
                select(valor = x, fecha)
        })
})

    j <- 1
    for (i in c("autoarima",
                "sobreparametrizacion",
                "arima_estandar",
                "original")) {
        ajustados[[j]] <- ajustados[[j]] %>%
            mutate(Serie = i) %>%
            select(Serie, fecha, valor)

        j <- j + 1
    }
    ajustados <- ajustados %>% do.call(rbind, .) %>%
        mutate(tipo = "estimacion")

    pronostico <-
        do.call(
            rbind,
            list(
                resultados_reales[[1]]$pronostico,
                resultados_reales[[2]]$pronostico,
                data.frame(pronostico = testing) %>%
                    t %>%
                    as.data.frame(),
                resultados_reales[[3]]$pronostico
            )
        )

     names(pronostico) <-
         c(
             forecast(x[[2]], length(testing)) %>% as.data.frame() %>% rownames() %>% paste("01", .) %>% dmy()
         )

     if (prod(is.na(names(pronostico))) > 0) {
         names(pronostico) <-
             paste0(2000:(2000 + length(names(pronostico)) - 1), "-01-01")
     }
    
    pronostico <- pronostico %>%
        mutate(Serie = c(
            "autoarima",
            "sobreparametrizacion",
            "original",
            "arima_estandar"
        )) %>%
        gather(fecha, valor, -Serie) %>%
        mutate(fecha = ymd(fecha),
               tipo = "pronostico")

    pronostico <- do.call(rbind, list(ajustados, pronostico)) %>%
        arrange(fecha, Serie) %>%
        mutate(Serie = factor(
            Serie,
            levels = c(
                "original",
                "autoarima",
                "sobreparametrizacion",
                "arima_estandar"
            ),
            labels = c(
                "Original",
                "auto.arima()",
                "Sobreparametrización",
                "ARIMA estándar"
            ),
            ordered = TRUE
        ))

    #####

    medidas <- do.call(
        rbind,
        list(
            resultados_reales[[1]]$medidas,
            resultados_reales[[2]]$medidas,
            resultados_reales[[3]]$medidas
        )
    ) %>%
        mutate(Serie = rep(
            c("autoarima", "sobreparametrizacion", "arima_estandar"),
            each = 2
        ),
        tipo = rep(c("training", "testing"), 3)) %>%
        select(Serie, tipo, AIC, AICc, BIC, RMSE, MAE, MAPE) %>%
        mutate(
            Serie = factor(
                Serie,
                levels = c("autoarima",
                           "sobreparametrizacion",
                           "arima_estandar"),
                labels = c("auto.arima()",
                           "Sobreparametrización",
                           "ARIMA estándar"),
                ordered = TRUE
            ),
            tipo = factor(
                tipo,
                levels = c("training", "testing"),
                labels = c("Entrenamiento", "Validación"),
                ordered = TRUE
            )
        ) %>%
        arrange(tipo, Serie)

    list(pronostico = pronostico,
         medidas = medidas)
}
```

```{r funcion_reordena_simulacion}
reordena_simulacion <- function(modelos, testing){

    l1 <- list(haa=modelos$autoarima,
         op=list(best_model=modelos$sobreparametrizacion),
         arima_estandar=modelos$arima_estandar)
    final <- attributes(l1[[1]]$x)$tsp[2]
    testing <- window(testing, start=final+1)
    list(testing=testing,
         haa=modelos$autoarima,
         op=list(best_model=modelos$sobreparametrizacion),
         arima_estandar=modelos$arima_estandar)
}
```

```{r}
extrae_ee <- function(modelo, testing){
    data.frame(ee=predict(modelo, n.ahead = length(testing), se.fit=T)$se)
}
```

\subsubsection{Datos simulados}

Las figuras \ref{fig:pronostico_arima100}, \ref{fig:pronostico_arima101}, \ref{fig:pronostico_arima203}, \ref{fig:pronostico_arima402}, \ref{fig:pronostico_arima001_011} y \ref{fig:pronostico_arima214_303} muestran el ajuste y el pronóstico de cada uno de los modelos estimados con la función `auto.arima()`, con sobreparametrización y con el modelo $ARIMA$ estándar. En todos los casos, la línea vertical punteada indica el inicio del periodo de pronóstico. 

Además, las figuras \ref{fig:ee_autoarima_arima100}, \ref{fig:ee_autoarima_arima101}, \ref{fig:ee_autoarima_arima203}, \ref{fig:ee_autoarima_arima402}, \ref{fig:ee_autoarima_arima001_011} y \ref{fig:ee_autoarima_arima214_303} representan el comportamiento de los errores estándar obtenidos de los pronósticos hechos con el mejor modelo sugerido por la función `auto.arima()`, las figuras \ref{fig:ee_sobreparametrizacion_arima100}, \ref{fig:ee_sobreparametrizacion_arima101}, \ref{fig:ee_sobreparametrizacion_arima203}, \ref{fig:ee_sobreparametrizacion_arima402}, \ref{fig:ee_sobreparametrizacion_arima001_011} y \ref{fig:ee_sobreparametrizacion_arima214_303} representan el comportamiento de los errores estándar obtenidos de los pronósticos hechos con el mejor modelo sugerido por la sobreparametrización, y por último, las figuras \ref{fig:ee_arima_estandar_arima100}, \ref{fig:ee_arima_estandar_arima101}, \ref{fig:ee_arima_estandar_arima203}, \ref{fig:ee_arima_estandar_arima402}, \ref{fig:ee_arima_estandar_arima001_011} y \ref{fig:ee_arima_estandar_arima214_303} representan el comportamiento de los errores estándar obtenidos de los pronósticos hechos con el modelo $ARIMA$ estándar.

```{r pronostico_arima100, fig.cap="Pronóstico de los datos generados mediante un ARIMA(1,0,0) según el método de estimación"}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_bajo[[1]]$modelos, arima100))

datos <- datos$pronostico %>%
    mutate(fecha = as.numeric(data.table::rleid(fecha)))


#datos <- resumen_resultados(TMII)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    #geom_ribbon(aes(x=fecha, ymin=LIred, ymax=LSred), fill="green", linetype=0, alpha=0.2)+
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia a partir de datos simulados\nauto.arima(): ARIMA(2,1,1)\nSobreparametrización: ARIMA(1,0,0)\nARIMA estándar: ARIMA(1,1,1)",
         y = "Valor",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    #scale_x_date(expand = c(0,0))+
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_arima100, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(1,0,0) con la función auto.arima()"}
mod <- comparacion_no_estacional_bajo[[1]]$modelos$autoarima
validacion <- arima100
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_arima100, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(1,0,0) con sobreparametrización"}
mod <- comparacion_no_estacional_bajo[[1]]$modelos$sobreparametrizacion
validacion <- arima100
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_arima100, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(1,0,0) con el modelo ARIMA estándar"}
mod <- comparacion_no_estacional_bajo[[1]]$modelos$arima_estandar
validacion <- arima100
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_arima101, fig.cap="Pronóstico de los datos generados mediante un ARIMA(1,0,1) según el método de estimación"}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_bajo[[2]]$modelos, arima101))

datos <- datos$pronostico %>%
    mutate(fecha = as.numeric(data.table::rleid(fecha)))


#datos <- resumen_resultados(TMII)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    #geom_ribbon(aes(x=fecha, ymin=LIred, ymax=LSred), fill="green", linetype=0, alpha=0.2)+
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia a partir de datos simulados\nauto.arima(): ARIMA(0,1,1)\nSobreparametrización: ARIMA(0,1,1)\nARIMA estándar: ARIMA(1,1,1)",
         y = "Valor",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    #scale_x_date(expand = c(0,0))+
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_arima101, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(1,0,1) con la función auto.arima()"}
mod <- comparacion_no_estacional_bajo[[2]]$modelos$autoarima
validacion <- arima101
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_arima101, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(1,0,1) con sobreparametrización"}
mod <- comparacion_no_estacional_bajo[[2]]$modelos$sobreparametrizacion
validacion <- arima101
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_arima101, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(1,0,1) con el modelo ARIMA estándar"}
mod <- comparacion_no_estacional_bajo[[2]]$modelos$arima_estandar
validacion <- arima101
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_arima203, fig.cap="Pronóstico de los datos generados mediante un ARIMA(2,0,3) según el método de estimación"}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_alto[[1]]$modelos, arima203))

datos <- datos$pronostico %>%
    mutate(fecha = as.numeric(data.table::rleid(fecha)))


#datos <- resumen_resultados(TMII)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    #geom_ribbon(aes(x=fecha, ymin=LIred, ymax=LSred), fill="green", linetype=0, alpha=0.2)+
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia a partir de datos simulados\nauto.arima(): ARIMA(1,0,3)\nSobreparametrización: ARIMA(0,0,5)\nARIMA estándar: ARIMA(1,1,1)",
         y = "Valor",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    #scale_x_date(expand = c(0,0))+
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_arima203, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(2,0,3) con la función auto.arima()"}
mod <- comparacion_no_estacional_alto[[1]]$modelos$autoarima
validacion <- arima203
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_arima203, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(2,0,3) con sobreparametrización"}
mod <- comparacion_no_estacional_alto[[1]]$modelos$sobreparametrizacion
validacion <- arima203
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_arima203, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(2,0,3) con el modelo ARIMA estándar"}
mod <- comparacion_no_estacional_alto[[1]]$modelos$arima_estandar
validacion <- arima203
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_arima402, fig.cap="Pronóstico de los datos generados mediante un ARIMA(4,0,2) según el método de estimación"}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_alto[[2]]$modelos, arima402))

datos <- datos$pronostico %>%
    mutate(fecha = as.numeric(data.table::rleid(fecha)))


#datos <- resumen_resultados(TMII)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    #geom_ribbon(aes(x=fecha, ymin=LIred, ymax=LSred), fill="green", linetype=0, alpha=0.2)+
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia a partir de datos simulados\nauto.arima(): ARIMA(1,1,3)\nSobreparametrización: ARIMA(1,1,0)\nARIMA estándar: ARIMA(1,1,1)",
         y = "Valor",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    #scale_x_date(expand = c(0,0))+
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_arima402, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(4,0,2) con la función auto.arima()"}
mod <- comparacion_no_estacional_alto[[2]]$modelos$autoarima
validacion <- arima402
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_arima402, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(4,0,2) con sobreparametrización"}
mod <- comparacion_no_estacional_alto[[2]]$modelos$sobreparametrizacion
validacion <- arima402
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_arima402, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(4,0,2) con el modelo ARIMA estándar"}
mod <- comparacion_no_estacional_alto[[2]]$modelos$arima_estandar
validacion <- arima402
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_arima001_011, fig.cap="Pronóstico de los datos generados mediante un ARIMA(0,0,1)(0,1,1) según el método de estimación"}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_estacional_bajo[[1]]$modelos, arima001_011))

datos <- datos$pronostico %>%
    mutate(fecha = as.numeric(data.table::rleid(fecha)))

#datos <- resumen_resultados(TMII)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    #geom_ribbon(aes(x=fecha, ymin=LIred, ymax=LSred), fill="green", linetype=0, alpha=0.2)+
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia a partir de datos simulados\nauto.arima(): ARIMA(0,0,1)(0,1,1)\nSobreparametrización: ARIMA(0,0,1)(0,1,1)\nARIMA estándar: ARIMA(1,1,1)(1,1,1)",
         y = "Valor",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    #scale_x_date(expand = c(0,0))+
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_arima001_011, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(0,0,1)(0,1,1) con la función auto.arima()"}
mod <- comparacion_estacional_bajo[[1]]$modelos$autoarima
validacion <- arima001_011
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_arima001_011, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(0,0,1)(0,1,1) con sobreparametrización"}
mod <- comparacion_estacional_bajo[[1]]$modelos$sobreparametrizacion
validacion <- arima001_011
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_arima001_011, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(0,0,1)(0,1,1) con el modelo ARIMA estándar"}
mod <- comparacion_estacional_bajo[[1]]$modelos$arima_estandar
validacion <- arima001_011
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_arima214_303, fig.cap="Pronóstico de los datos generados mediante un ARIMA(2,1,4)(3,0,3) según el método de estimación"}
reordena_simulacion2 <- function(modelos, testing){

    l1 <- list(haa=modelos$autoarima,
         op=list(best_model=modelos$sobreparametrizacion),
         arima_estandar=modelos$arima_estandar)
    final <- attributes(l1[[1]]$x)$tsp[2]
    testing <- window(testing, start=final)
    list(testing=testing,
         haa=modelos$autoarima,
         op=list(best_model=modelos$sobreparametrizacion),
         arima_estandar=modelos$arima_estandar)
}
datos <-
    resumen_resultados(reordena_simulacion2(comparacion_estacional_alto[[2]]$modelos, arima214_303))

datos <- datos$pronostico %>%
    mutate(fecha = as.numeric(data.table::rleid(fecha)))

#datos$pronostico %>% group_by(Serie) %>% summarise(n())
#datos <- resumen_resultados(TMII)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    #geom_ribbon(aes(x=fecha, ymin=LIred, ymax=LSred), fill="green", linetype=0, alpha=0.2)+
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia a partir de datos simulados\nauto.arima(): ARIMA(1,1,2)(2,1,1)\nSobreparametrización: ARIMA(1,1,2)(2,1,2)\nARIMA estándar: ARIMA(1,1,1)(1,1,1)",
         y = "Valor",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    #scale_x_date(expand = c(0,0))+
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_arima214_303, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(2,1,4)(3,0,3) con la función auto.arima()"}
mod <- comparacion_estacional_alto[[2]]$modelos$autoarima
validacion <- arima214_303
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_arima214_303, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(2,1,4)(3,0,3) con sobreparametrización"}
mod <- comparacion_estacional_alto[[2]]$modelos$sobreparametrizacion
validacion <- arima214_303
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_arima214_303, fig.cap="Errores estándar de los pronósticos obtenidos de los datos generados mediante un ARIMA(2,1,4)(3,0,3) con el modelo ARIMA estándar"}
mod <- comparacion_estacional_alto[[2]]$modelos$arima_estandar
validacion <- arima214_303
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

\subsubsection{Datos reales}

De la misma manera en que se hizo con los datos simulados, las figuras \ref{fig:pronostico_TMII}, \ref{fig:pronostico_EXTERNA}, \ref{fig:pronostico_INCENTIVOS} y \ref{fig:pronostico_INTERESES}. La línea vertical punteada marca el inicio del pronóstico.

Además, para las series de la tasa de mortalidad infantil interanul, la de mortalidad por causa externa, la series de incentivos y la de intereses y comisiones, se resumen visualmente los errores estándar obtenidos con la función `auto.arima()` en las figuras \ref{fig:ee_autoarima_TMII}, \ref{fig:ee_autoarima_EXTERNA}, \ref{fig:ee_autoarima_INCENTIVOS} y \ref{fig:ee_autoarima_INTERESES}, respectivamente. De manera similar, pero utilizando la sobreparametrización, los errores estándar de las series de la tasa de mortalidad infantil interanul, la de mortalidad por causa externa, la series de incentivos y la de intereses y comisiones, se resumen visualmente en las figuras \ref{fig:ee_sobreparametrizacion_TMII}, \ref{fig:ee_sobreparametrizacion_EXTERNA}, \ref{fig:ee_sobreparametrizacion_INCENTIVOS} y \ref{fig:ee_sobreparametrizacion_INTERESES}, respectivamente. Por último, para las mismas series cronológicas, los errores estándar obtenidos con el modelo $ARIMA$ estándar se resumen en las figuras \ref{fig:ee_arima_estandar_TMII}, \ref{fig:ee_arima_estandar_EXTERNA}, \ref{fig:ee_arima_estandar_INCENTIVOS} y \ref{fig:ee_arima_estandar_INTERESES}.

```{r pronostico_TMII, fig.cap="Pronóstico de la TMII según el método de estimación"}
datos <- resumen_resultados(TMII)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia.\nauto.arima(): ARIMA(2,1,0)(0,0,1).\nSobreparametrización: ARIMA(4,1,0)(4,1,0).\nARIMA estándar: ARIMA(1,1,1)(1,1,1).",
         y = "TMII",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    scale_x_date(expand = c(0,0), date_breaks = "3 years", date_labels = "%Y")+
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_TMII, fig.cap="Errores estándar de los pronósticos obtenidos para la TMII con la función auto.arima()"}
mod <- TMII$haa
validacion <- TMII$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_TMII, fig.cap="Errores estándar de los pronósticos obtenidos para la TMII con sobreparametrización"}
mod <- TMII$op$best_model
validacion <- TMII$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_TMII, fig.cap="Errores estándar de los pronósticos obtenidos para la TMII con el modelo ARIMA estándar"}
mod <- TMII$arima_estandar
validacion <- TMII$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_EXTERNA, fig.cap="Pronóstico de la Tasa de mortalidad por causa externa (TMCE) según el método de estimación"}
datos <- resumen_resultados(EXTERNA)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia.\nauto.arima(): ARIMA(1,1,1).\nSobreparametrización: ARIMA(2,0,1)(0,1,1).\nARIMA estándar: ARIMA(1,1,1)(1,1,1).",
         y = "TMCE",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    scale_x_date(expand = c(0,0), date_breaks = "3 years", date_labels = "%Y")+
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_EXTERNA, fig.cap="Errores estándar de los pronósticos obtenidos para la Tasa de mortalidad por causa externa (TMCE) con la función auto.arima()"}
mod <- EXTERNA$haa
validacion <- EXTERNA$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_EXTERNA, fig.cap="Errores estándar de los pronósticos obtenidos para la Tasa de mortalidad por causa externa (TMCE) con sobreparametrización"}
mod <- EXTERNA$op$best_model
validacion <- EXTERNA$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_EXTERNA, fig.cap="Errores estándar de los pronósticos obtenidos para la Tasa de mortalidad por causa externa (TMCE) con el modelo ARIMA estándar"}
mod <- EXTERNA$arima_estandar
validacion <- EXTERNA$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_INCENTIVOS, fig.cap="Pronóstico de la serie de incentivos salariales del sector público según el método de estimación"}
datos <- resumen_resultados(INCENTIVOS)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia.\nauto.arima(): ARIMA(0,0,1)(1,1,0).\nSobreparametrización: ARIMA(2,1,0)(1,2,0).\nARIMA estándar: ARIMA(1,1,1)(1,1,1).",
         y = "Incentivos",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    scale_x_date(expand = c(0,0), date_breaks = "3 years", date_labels = "%Y")+
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_INCENTIVOS, fig.cap="Errores estándar de los pronósticos obtenidos para la serie de incentivos salariales del sector público con la función auto.arima()"}
mod <- INCENTIVOS$haa
validacion <- INCENTIVOS$testing
fc <- forecast(mod, h = length(validacion))
descriptive_plot(data.frame(ee=as.numeric((fc$upper[,2] - fc$lower[,2]) / (2 * qnorm(.5 + fc$level[2] / 200)))),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_INCENTIVOS, fig.cap="Errores estándar de los pronósticos obtenidos para la serie de incentivos salariales del sector público con sobreparametrización"}
mod <- INCENTIVOS$op$best_model
validacion <- INCENTIVOS$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_INCENTIVOS, fig.cap="Errores estándar de los pronósticos obtenidos para la serie de incentivos salariales del sector público con el modelo ARIMA estándar"}
mod <- INCENTIVOS$arima_estandar
validacion <- INCENTIVOS$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r pronostico_INTERESES, fig.cap="Pronóstico de la serie de intereses y comisiones del sector público según el método de estimación"}
datos <- resumen_resultados(INTERESES)$pronostico
corte <- which(datos$tipo == "pronostico")[1]
corte <- datos$fecha[corte]
ggplot(datos, aes(x = fecha, y = valor, colour = Serie)) +
    geom_line(size = 0.8) +
    scale_color_manual(values = c("limegreen", "orangered1", "blue", "salmon4")) +
    geom_vline(xintercept = corte, linetype = "dotdash") +
    theme_minimal() +
    theme(text = element_text(size = 9),
          axis.text.x = element_text(angle = 0, hjust = 1)) +
    labs(caption = "Fuente: Elaboración propia.\nauto.arima(): ARIMA(0,0,1)(0,1,0).\nSobreparametrización: ARIMA(0,1,2)(0,1,0).\nARIMA estándar: ARIMA(1,1,1)(1,1,1).",
         y = "Intereses y comisiones",
         x = "Periodo") +
    theme(
        plot.title = element_text(hjust = 0.5, face = "plain"),
        plot.caption = element_text(
            hjust = 0,
            vjust = 0.5,
            margin = margin(t = 1, 10, 10, 10)
        )
    ) +
    scale_x_date(expand = c(0,0), date_breaks = "3 years", date_labels = "%Y")+
    scale_y_continuous(expand = c(0, 0))
```

```{r ee_autoarima_INTERESES, fig.cap="Errores estándar de los pronósticos obtenidos para la serie de intereses y comisiones del sector público con la función auto.arima()"}
mod <- INTERESES$haa
validacion <- INTERESES$testing
fc <- forecast(mod, h = length(validacion))
descriptive_plot(data.frame(ee=as.numeric((fc$upper[,2] - fc$lower[,2]) / (2 * qnorm(.5 + fc$level[2] / 200)))),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_sobreparametrizacion_INTERESES, fig.cap="Errores estándar de los pronósticos obtenidos para la serie de intereses y comisiones del sector público con sobreparametrización"}
mod <- INTERESES$op$best_model
validacion <- INTERESES$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

```{r ee_arima_estandar_INTERESES, fig.cap="Errores estándar de los pronósticos obtenidos para la serie de intereses y comisiones del sector público con el modelo ARIMA estándar"}
mod <- INTERESES$arima_estandar
validacion <- INTERESES$testing
descriptive_plot(extrae_ee(mod, validacion),ee, labels="Error Estándar", ylab="Densidad")[[1]]
```

\subsection{Medidas de bondad de ajuste y de rendimiento}

Para complementar los resultados visualizados en la sección anterior, se calculan las medidas de bondad de ajuste obtenidas con el conjunto de datos de entrenamiento, y las medidas de rendimiento obtenidas tanto en el conjunto de entrenamiento como en el conjunto de validación. Ambos resultados para los datos simulados y para los datos reales. 

\subsubsection{Datos simulados}

A partir de las series cronológicas simuladas, las medidas de bondad de ajuste y de rendimiento para cada una de las series simuladas se muestran en las tablas \ref{tab:comparaciones_arima100}, \ref{tab:comparaciones_arima101}, \ref{tab:comparaciones_arima203}, \ref{tab:comparaciones_arima402}, \ref{tab:comparaciones_arima001_011} y \ref{tab:comparaciones_arima214_303}.

```{r}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_bajo[[1]]$modelos, arima100))

datos <- datos$medidas

#datos <- resumen_resultados(TMII)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_arima100}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados a partir de un ARIMA(1,0,0)",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia a partir de datos simulados",
            "auto.arima(): ARIMA(1,0,0)",
            "Sobreparametrización: ARIMA(1,0,0)",
            "ARIMA estándar: ARIMA(1,1,1)"
        ),
        general_title = ""
    ) 
```

```{r}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_bajo[[2]]$modelos, arima101))

datos <- datos$medidas

#datos <- resumen_resultados(TMII)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_arima101}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados a partir de un ARIMA(1,0,1)",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia a partir de datos simulados",
            "auto.arima(): ARIMA(0,0,1)",
            "Sobreparametrización: ARIMA(0,0,1)",
            "ARIMA estándar: ARIMA(1,1,1)"
        ),
        general_title = ""
    ) 
```

```{r}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_alto[[1]]$modelos, arima203))

datos <- datos$medidas

#datos <- resumen_resultados(TMII)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_arima203}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados a partir de un ARIMA(2,0,3)",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia a partir de datos simulados",
            "auto.arima(): ARIMA(2,0,2)",
            "Sobreparametrización: ARIMA(5,1,1)",
            "ARIMA estándar: ARIMA(1,1,1)"
        ),
        general_title = ""
    ) 
```


```{r}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_no_estacional_alto[[2]]$modelos, arima402))

datos <- datos$medidas

#datos <- resumen_resultados(TMII)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_arima402}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados a partir de un ARIMA(4,0,2)",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia a partir de datos simulados",
            "auto.arima(): ARIMA(2,0,3)",
            "Sobreparametrización: ARIMA(4,0,2)",
            "ARIMA estándar: ARIMA(1,1,1)"
        ),
        general_title = ""
    ) 
```

```{r}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_estacional_bajo[[1]]$modelos, arima001_011))

datos <- datos$medidas

#datos <- resumen_resultados(TMII)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_arima001_011}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados a partir de un ARIMA(0,0,1)(0,1,1)",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia a partir de datos simulados",
            "auto.arima(): ARIMA(0,0,1)(0,1,1)",
            "Sobreparametrización: ARIMA(0,0,1)(0,1,1)",
            "ARIMA estándar: ARIMA(1,1,1)(1,1,1)"
        ),
        general_title = ""
    ) 
```

```{r}
datos <-
    resumen_resultados(reordena_simulacion(comparacion_estacional_alto[[2]]$modelos, arima214_303))

datos <- datos$medidas

#datos <- resumen_resultados(TMII)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_arima214_303}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados a partir de un ARIMA(2,1,4)(3,0,3)",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia a partir de datos simulados",
            "auto.arima(): ARIMA(2,0,4)(0,0,2)",
            "Sobreparametrización: ARIMA(2,1,3)(0,1,3)",
            "ARIMA estándar: ARIMA(1,1,1)(1,1,1)"
        ),
        general_title = ""
    ) 
```

\subsubsection{Datos reales}

De manera análoga, se muestran las medidas de bondad de ajuste y de rendimiento para las series cronológicas reales en los cuadros \ref{tab:comparaciones_TMII}, \ref{tab:comparaciones_EXTERNA}, \ref{tab:comparaciones_INCENTIVOS} y \ref{tab:comparaciones_INTERESES}.

```{r}
datos <- resumen_resultados(TMII)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_TMII}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados para la TMII",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia",
            "auto.arima(): ARIMA(2,1,0)(0,0,1)",
            "Sobreparametrización: ARIMA(4,1,0)(4,1,0)",
            "ARIMA estándar: ARIMA(1,1,1)(1,1,1)"
        ),
        general_title = ""
    ) 
```

```{r}
datos <- resumen_resultados(EXTERNA)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_EXTERNA}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados para la TMCE",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia",
            "auto.arima(): ARIMA(1,1,1)",
            "Sobreparametrización: ARIMA(2,0,1)(0,1,1)",
            "ARIMA estándar: ARIMA(1,1,1)(1,1,1)"
        ),
        general_title = ""
    ) 
```

```{r}
datos <- resumen_resultados(INCENTIVOS)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_INCENTIVOS}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados para la serie de incentivos salariales del sector público",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia",
            "auto.arima(): ARIMA(0,0,1)(1,1,0)",
            "Sobreparametrización: ARIMA(2,1,0)(1,2,0)",
            "ARIMA estándar: ARIMA(1,1,1)(1,1,1)"
        ),
        general_title = ""
    ) 
```

```{r}
datos <- resumen_resultados(INTERESES)$medidas

datos %>%
    data.frame(row.names = NULL) %>%
    select(tipo, Serie, everything()) %>%
    mutate_if(is.numeric, function(x)
        as.character(round(x, 4))) %>%
    mutate(
        AIC = ifelse(tipo == "Validación", "", AIC),
        AICc = ifelse(tipo == "Validación", "", AICc),
        BIC = ifelse(tipo == "Validación", "", BIC)
    ) %>%
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:comparaciones_INTERESES}Medidas de bondad de ajuste y de rendimiento según el método de estimación para los conjuntos de entrenamiento y validación simulados para la serie de intereses y comisiones del sector público",
        col.names = c(
            "Conjunto de datos",
            "Estimación",
            "AIC",
            "AICc",
            "BIC",
            "RMSE",
            "MAE",
            "MAPE"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    column_spec(1, width = "2.5cm") %>%
    collapse_rows(columns = 1) %>%
    column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia",
            "auto.arima(): ARIMA(0,0,1)(0,1,0)",
            "Sobreparametrización: ARIMA(0,1,2)(0,1,0)",
            "ARIMA estándar: ARIMA(1,1,1)(1,1,1)"
        ),
        general_title = ""
    ) 
```