```{r, echo=FALSE}
load(popstudy::read_from_dir("Resultados_2022.RData", "Output/Results"))
# Para comparar los tiempos
comparar_tiempos <- function(obj){
  obj$tiempos %>% 
    sapply(function(x){
      difftime(x[[2]], x[[1]], "mins")
    })
}

tiempos_simulaciones <- lapply(list(
  comparacion_no_estacional_bajo = comparacion_no_estacional_bajo,
  comparacion_no_estacional_alto = comparacion_no_estacional_alto,
  comparacion_estacional_bajo = comparacion_estacional_bajo,
  comparacion_estacional_alto = comparacion_estacional_alto
), function(x) {
  sapply(x, comparar_tiempos)
})
tiempos_reales <- sapply(
  list(
    TMII = TMII,
    EXTERNA = EXTERNA,
    INCENTIVOS = INCENTIVOS,
    INTERESES = INTERESES
  ),
  comparar_tiempos
)

especificaciones <- list()
k <- 1
for(i in 1:length(names(tiempos_simulaciones))){
  for(j in 1:2){
    especificaciones[[k]] <- paste0("summary(", names(tiempos_simulaciones)[i], "[[", j, "]]$modelos$original)")
    k <- k+1
  }
}

names(especificaciones) <- rep(names(tiempos_simulaciones), each=2)

tiempos_simulaciones <- tiempos_simulaciones %>% 
  do.call(cbind, .) %>% 
  as.data.frame()
names(tiempos_simulaciones) <- sapply(especificaciones, function(x){
  x <- capture.output(eval(parse(text = x)))
  substr(x[2],1, 100L)
})

tiempos_de_estimacion <- do.call(cbind, list(tiempos_simulaciones, as.data.frame(tiempos_reales)))
rm(tiempos_simulaciones)
rm(tiempos_reales)
rm(especificaciones)

tiempos_de_estimacion <- tiempos_de_estimacion %>% 
    mutate(estimacion=row.names(tiempos_de_estimacion)) %>% 
    select(estimacion, everything()) %>% 
    data.frame(row.names = NULL) %>% 
    mutate_if(is.numeric, round, 4)

names(tiempos_de_estimacion) <- c("Estimación",'ARIMA(1,0,0)',"ARIMA(1,0,1)", "ARIMA(2,0,3)", "ARIMA(4,0,2)", "ARIMA(0,0,1)(0,1,1)[12]", "ARIMA(1,1,0)(1,1,0)[12]", "ARIMA(2,1,4)(4,1,4)[12]", "ARIMA(2,1,4)(3,0,3)[12]","TMII", "EXTERNA","INCENTIVOS","INTERESES")

tiempos_de_estimacion %>%
    gather(serie, minutos, -Estimación) %>% 
    pivot_wider(names_from = Estimación, values_from = minutos) %>% 
    kbl(
        .,
        "latex",
        booktabs = T,
        escape = F,
        align = "r",
        caption = "\\label{tab:tiempos_estimacion}Tiempos de estimación en minutos para cada modelo según su tipo de estimación.",
        col.names = c(
            "Serie",
            "autoarima",
            "Sobreparametrización",
            "ARIMA estándar"
        )
    ) %>%
    kable_styling(
        latex_options = c("scale_down", "repeat_header", "hold_position"),
        full_width = T,
        font_size = 7
    ) %>%
    # column_spec(1, width = "2.5cm") %>%
    # collapse_rows(columns = 1) %>%
    # column_spec(2, width = "2.5cm") %>%
    footnote(
        general = c(
            "Fuente: Elaboración propia"
        ),
        general_title = ""
    )
```



```{r, ref="funcion_op_arima", codecap = "Función op.arima", echo=FALSE, eval=FALSE}
#\subsection{Función de sobreparametrización}
op.arima <- function(arima_process = c(p = 1, d = 1, q = 1,
                                       P = 1, D = 1, Q = 1),
                     seasonal_periodicity,
                     time_serie, reg = NULL, horiz = 12,
                     prop=.8, training_weight=.2, testing_weight=.8,
                     parallelize=FALSE,
                     clusters=detectCores(logical = FALSE),...){

    data_partition <- round(length(time_serie)*prop, 0)
    train <<- subset(time_serie, end=data_partition)
    test <<- subset(time_serie, start=data_partition+1)

    arima_model <- function(time_serie, non_seasonal, seasonal, periodic, 
                            regr = NULL,...){

        if(is.list(non_seasonal)){
            non_seasonal <- unlist(non_seasonal)
        }

        if(is.list(seasonal)){
            seasonal <- unlist(seasonal)
        }

        seasonal_part <- list(order=seasonal, period=periodic)
        if(is.null(regr)){
            arima_model <- tryCatch({
                Arima(time_serie,
                      order = non_seasonal,
                      seasonal = seasonal_part,...)
            },
            error = function(e) NULL)
        }

        if(!is.null(regr)){
            arima_model <-tryCatch({
                Arima(time_serie,
                      order = non_seasonal,
                      seasonal = seasonal_part,
                      xreg = regr,...)
            },
            error = function(e) NULL)
        }

        if(!is.null(arima_model)){
            degrees_of_freedom <- arima_model$nobs - length(arima_model$coef)
            t_value <- arima_model$coef/sqrt(diag(arima_model$var.coef))
            prob <- stats::pf(t_value^2, df1 = 1, df2 = degrees_of_freedom, 
                              lower.tail = FALSE)
            ifelse(sum(1*prob>0.05)<1, return(arima_model), 1)
        }

    }

    arima_measures <- function(arima_model, testing, horizon, regr = NULL){


        model_spec <- capture.output(arima_model)
        model_spec <- substr(model_spec[2],1, 23)

     
        data <- capture.output(summary(arima_model))
        data <- data[grepl("AIC", data) == T]
        model_info <- strsplit(data, " ")
        pos <- which(sapply(model_info, nchar)>0)
        model_info <- model_info[[1]][pos]
        model_info <- do.call("rbind", strsplit(model_info, "=")) %>%
            data.frame()
        colnames(model_info) <- c("Medida", "Valor")
        model_info <- model_info %>%
            mutate(Valor = as.numeric(as.character(Valor))) %>%
            spread(Medida, Valor) %>%
            data.frame(arima_model = model_spec)


        model_performance <- data.frame(arima_model = c(model_spec, 
                                                        paste(model_spec,
                                                              "Validacion")),
                                        accuracy(forecast(arima_model, horizon, 
                                                          xreg = regr),
                                                 testing))
        merge(model_info, model_performance, by="arima_model", all = TRUE) %>%
            select(arima_model, AIC, AICc, BIC, MAE, RMSE, MASE)
    }


    arima_selected <- function(model_table, Wtrain=training_weight, 
                               Wtest=testing_weight){

        model_table <- model_table %>%
            distinct(arima_model, .keep_all = TRUE)

        model_table <- model_table %>%
            mutate(mod = as.character(c(0, rep(1:(nrow(model_table)-1)%/%2))))

        tabla2 <- model_table %>%
            mutate_at(vars(contains("C")), function(x){x-min(x, na.rm=TRUE)}) %>%
            mutate_if(is.numeric, function(x) ifelse(is.na(x),0,x)) %>%
            mutate(puntaje = AIC+AICc+BIC+MAE+RMSE+MASE,
                   ponde = ifelse(grepl("Validacion", arima_model)==TRUE,
                                  Wtest, Wtrain),
                   puntaje = puntaje*ponde)

        suppressMessages({
            minimal_score <- tabla2 %>%
                group_by(mod) %>%
                summarise(puntaje=sum(puntaje)) %>%
                ungroup
        })

        pos <- minimal_score$mod[which(
          minimal_score$puntaje==min(minimal_score$puntaje))]

        model_table %>%
            filter(mod %in% pos) %>%
            dplyr::select(arima_model:MASE)
    }

    suppressWarnings({
        valores <- expand.grid(p = 0:arima_process[1], 
                               d = 0:arima_process[2], 
                               q = 0:arima_process[3],
                               P = 0:arima_process[4], 
                               D = 0:arima_process[5], 
                               Q = 0:arima_process[6])

        non_seasonal_values <- split(as.matrix(valores[, 1:3]),
                                     row(valores[, 1:3]))
        seasonal_values <- split(as.matrix(valores[, 4:6]),
                                 row(valores[, 4:6]))

        if(parallelize==FALSE){
            arima_models <- mapply(arima_model,
                                   non_seasonal=non_seasonal_values,
                                   seasonal=seasonal_values,
                                   MoreArgs = list(time_serie=train, 
                                                   regr=reg, 
                                      periodic=seasonal_periodicity),
                                   SIMPLIFY = FALSE)
        }else({

            clp <- makeCluster(clusters, type = "SOCK", useXDR=FALSE)

            clusterEvalQ(clp, expr = {
                library(forecast)
            })

            arima_models <- clusterMap(cl=clp, fun = arima_model,
                                       non_seasonal=non_seasonal_values,
                                       seasonal=seasonal_values,
                                       MoreArgs = list(time_serie=train, regr=reg, periodic=seasonal_periodicity),
                                       SIMPLIFY = FALSE, .scheduling = "dynamic")
            stopCluster(clp)

        })

        pos <- which(sapply(lapply(arima_models, class), length)>1)

        final_measures <- do.call("rbind", lapply(arima_models[pos],
                                                  arima_measures,
                                                  testing = test,
                                                  horizon= horiz,
                                                  regr = reg)) %>%
            mutate_if(is.numeric, round, 2)
        
        final_list <- list(arima_models=arima_models[pos],
                           final_measures=final_measures,
                           bests=arima_selected(final_measures, Wtrain = training_weight, Wtest = testing_weight))

        mod_index <- final_list$bests %>%
            row.names %>%
            as.numeric %>%
            floor %>%
            unique %>%
            as.character

        final_list$best_model <- eval(parse(text = paste0(
          "final_list$arima_models$", "`", mod_index, "`")))

        final_list
    })
}
```



```{r, ref="simula_series", codecap = "Función ts.sim", echo=FALSE, eval=FALSE}
#\subsection{Función de simulación de series cronológicas}
ts.sim <- function(data,
                   n,
                   temporalidad,
                   no.estacional,
                   estacional = c(0, 0, 0),
                   p = NULL,
                   q = NULL,
                   P = NULL,
                   Q = NULL) {
    require(forecast)
    tryCatch({
        coeficientes <- list(p, q, P, Q)
        coeficientes.simulados <- lapply(c(no.estacional[c(1, 3)],
                                           estacional[c(1, 3)]),
                                         function(x)
                                             sample(seq(-1, 1, .1), x))
        
        pos <- which(sapply(coeficientes, is.null) == TRUE)
        pos2 <- which(sapply(coeficientes.simulados, length) > 0)
        
        coeficientes[pos] <- coeficientes.simulados[pos]
        
        names(coeficientes) <- c("p", "q", "P", "Q")
        coeficientes <- coeficientes[pos2]
        
        if (TRUE %in% (c("P", "Q") %in% names(coeficientes))) {
            modelo <- Arima(
                ts(data = data, freq = temporalidad),
                order = no.estacional,
                seasonal = estacional,
                fixed = c(unlist(coeficientes))
            )
        } else
            ({
                modelo <- Arima(
                    ts(data = data, freq = temporalidad),
                    order = no.estacional,
                    seasonal = estacional,
                    fixed = c(unlist(coeficientes), NA)
                )
            })
        
        datos <- simulate(modelo, nsim=(n+length(data)))
        
        datos <- subset(datos, start=length(data)+1)
        list(modelo=modelo, datos=datos)},
        error = function(e)
            ts.sim(data, n, temporalidad,
                   no.estacional, estacional,
                   p, q, P, Q))
}
```

