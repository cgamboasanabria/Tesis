```{r}
carlians::requeridos(dplyr)
```


```{r}
simular.proceso <- function(data, n, temporalidad, 
                            no.estacional, estacional=c(0,0,0), 
                            p=NULL, q=NULL, P=NULL, Q=NULL){
  
  require(forecast)
  tryCatch({
      coeficientes <- list(p, q, P, Q)
      coeficientes.simulados <- lapply(c(no.estacional[c(1,3)], 
                                         estacional[c(1,3)]), 
                                       function(x) sample(seq(-1,1,.1), x))
      
    pos <- which(sapply(coeficientes, is.null)==TRUE)
    pos2 <- which(sapply(coeficientes.simulados, length)>0)
    
    coeficientes[pos] <- coeficientes.simulados[pos]
    
    names(coeficientes) <- c("p", "q", "P", "Q")
    coeficientes <- coeficientes[pos2]
    
    if(TRUE %in% (c("P", "Q") %in% names(coeficientes))){
        modelo <- Arima(ts(data=data, freq=temporalidad), 
                    order = no.estacional, 
                    seasonal = estacional,
                    fixed=c(unlist(coeficientes)))
    }else({
        modelo <- Arima(ts(data=data, freq=temporalidad), 
                    order = no.estacional, 
                    seasonal = estacional,
                    fixed=c(unlist(coeficientes), NA))
    })
    
    datos <- simulate(modelo, nsim=(n+length(data)))
    
    datos <- subset(datos, start=length(data)+1)
    list(modelo=modelo, datos=datos)}, 
    error = function(e) simular.proceso(data, n, temporalidad,
                                        no.estacional, estacional, 
                                        p, q, P, Q))
}
# simular.proceso(data=rnorm(100, 15, 2), n=500, temporalidad=12,
#                 no.estacional=c(1,0,3),
#                 estacional = c(1,2,2),
#                 q=c(.1, .5, .9))
# simular.proceso(data=rnorm(100, 15, 2), n=500, temporalidad=1,
#                 no.estacional=c(1,0,3),
#                 estacional = c(0,0,0),
#                 q=c(.1, .5, .9))
```

# Escenarios para simulación de series

```{r}
escenarios <- expand.grid(p=0:1, d=0:1, q=0:1,P=0:1, D=0:1, Q=0:1)
no_estacional <- escenarios %>% 
    select(p:q)
no_estacional <- no_estacional[rowSums(no_estacional)>0,] %>% 
    unique

estacional <- escenarios[rowSums(escenarios)>0,]
estacional <- estacional[rowSums(estacional[,4:6])>0,] 
estacional <- estacional[rowSums(estacional[,1:3])>0,] %>% 
    unique

no_estacional_bajo <- no_estacional
estacional_bajo <- estacional

# Altos

escenarios <- expand.grid(p=2:4, d=0:1, q=2:4,P=2:4, D=0:1, Q=2:4)
no_estacional <- escenarios %>% 
    select(p:q)
no_estacional <- no_estacional[rowSums(no_estacional)>0,] %>% 
    unique

estacional <- escenarios[rowSums(escenarios)>0,]
estacional <- estacional[rowSums(estacional[,4:6])>0,] 
estacional <- estacional[rowSums(estacional[,1:3])>0,] %>% 
    unique

no_estacional_alto <- no_estacional
estacional_alto <- estacional
rm(no_estacional)
rm(estacional)

no_estacional_bajo; no_estacional_alto; estacional_bajo; estacional_alto
```

# Simulación de datos

```{r}
set.seed(16051989)
dat <- rnorm(100, 10, 1)
# no_estacional_bajo <- no_estacional_bajo[sample(1:nrow(no_estacional_bajo), 2, replace = FALSE),]
# no_estacional_alto <- no_estacional_alto[sample(1:nrow(no_estacional_alto), 2, replace = FALSE),]
# proceso_no_estacional <- do.call(rbind, list(no_estacional_bajo, no_estacional_alto))
# estacional_bajo <- estacional_bajo[sample(1:nrow(estacional_bajo), 2, replace = FALSE),]
# estacional_alto <- estacional_alto[sample(1:nrow(estacional_alto), 2, replace = FALSE),]
# proceso_estacional <- do.call(rbind, list(estacional_bajo, estacional_alto))


pos_no_estacional_bajo <- sample(1:nrow(no_estacional_bajo), nrow(no_estacional_bajo), replace = FALSE)
pos_no_estacional_alto <- sample(1:nrow(no_estacional_alto), nrow(no_estacional_alto), replace = FALSE)

pos_estacional_bajo <- sample(1:nrow(estacional_bajo), nrow(estacional_bajo), replace = FALSE)
pos_estacional_alto <- sample(1:nrow(estacional_alto), nrow(estacional_alto), replace = FALSE)



popstudy::descriptive_plot(data = data.frame(Yt=dat), labels = NULL, Yt)

# proceso_no_estacional <- mapply(function(dat_,p_,d_,q_){
#     simular.proceso(data=dat_, 
#                     n=500, 
#                     temporalidad=1,
#                     no.estacional=c(p_,d_,q_))
# }, 
# p_=proceso_no_estacional$p, 
# d_=proceso_no_estacional$d, 
# q_=proceso_no_estacional$q,
# MoreArgs = list(dat_=dat))

resultados_no_estacional_bajo <- lapply(pos_no_estacional_bajo, function(x){
  
  pdq <- no_estacional_bajo[x,1:3] %>% unlist 
  tryCatch({simular.proceso(data=dat, n=500, temporalidad=1,
                  no.estacional=pdq)}, 
           error=function(e) NULL)
  
  
})
resultados_no_estacional_bajo <- resultados_no_estacional_bajo[!sapply(resultados_no_estacional_bajo, is.null)][1:2]

resultados_no_estacional_alto <- lapply(pos_no_estacional_alto, function(x){
  
  pdq <- no_estacional_alto[x,1:3] %>% unlist 
  tryCatch({simular.proceso(data=dat, n=500, temporalidad=1,
                  no.estacional=pdq)}, 
           error=function(e) NULL)
  
  
})
resultados_no_estacional_alto <- resultados_no_estacional_alto[!sapply(resultados_no_estacional_alto, is.null)][1:2]


resultados_estacional_bajo <- lapply(pos_estacional_bajo, function(x){
  
  pdq <- estacional_bajo[x,1:3] %>% unlist
  PDQ <- estacional_bajo[x,4:6] %>% unlist
  tryCatch({simular.proceso(data=dat, n=500, temporalidad=12,
                  no.estacional=pdq,
                  estacional = PDQ)}, 
           error=function(e) NULL)
  
  
})
resultados_estacional_bajo <- resultados_estacional_bajo[!sapply(resultados_estacional_bajo, is.null)][1:2]

resultados_estacional_alto <- lapply(pos_estacional_alto, function(x){
  
  pdq <- estacional_alto[x,1:3] %>% unlist
  PDQ <- estacional_alto[x,4:6] %>% unlist
  tryCatch({simular.proceso(data=dat, n=500, temporalidad=12,
                  no.estacional=pdq,
                  estacional = PDQ)}, 
           error=function(e) NULL)
  
  
})
resultados_estacional_alto <- resultados_estacional_alto[!sapply(resultados_estacional_alto, is.null)][1:2]
```

# Comparacion de resultados



```{r}
op.arima <- function(arima_process = c(p = 1, d = 1, q = 1, 
                                       P = 1, D = 1, Q = 1), 
                     seasonal_periodicity,
                     time_serie, reg = NULL, horiz = 12,
                     prop=.8, training_weight=.2, testing_weight=.8,
                     parallelize=FALSE, clusters=detectCores(logical = FALSE),...){
    
    data_partition <- round(length(time_serie)*prop, 0)
    train <<- subset(time_serie, end=data_partition)
    test <<- subset(time_serie, start=data_partition+1)
    
    ####################################################################################    
    arima_model <- function(time_serie, non_seasonal, seasonal, periodic, regr = NULL){
        
        seasonal_part <- list(order=seasonal, period=periodic)
        if(is.null(regr)){
            arima_model <- tryCatch({
                Arima(time_serie, 
                      order = non_seasonal, 
                      seasonal = seasonal_part,...)
            }, 
            error = function(e) NULL)  
        }
        
        if(!is.null(regr)){
            arima_model <-tryCatch({
                Arima(time_serie, 
                      order = non_seasonal, 
                      seasonal = seasonal_part, 
                      xreg = regr,...)
            }, 
            error = function(e) NULL)   
        }
        
        if(!is.null(arima_model)){
            degrees_of_freedom <- arima_model$nobs - length(arima_model$coef)
            t_value <- arima_model$coef/sqrt(diag(arima_model$var.coef))
            prob <- stats::pf(t_value^2, df1 = 1, df2 = degrees_of_freedom, lower.tail = FALSE)
            ifelse(sum(1*prob>0.05)<1, return(arima_model), 1)
        }
        
    }
    ############################################################################################
    #Estimación de las final_measures de model_performance y los criterios de información
    arima_measures <- function(arima_model, testing, horizon, regr = NULL){
        
        ##model_spec del arima_model
        model_spec <- capture.output(arima_model)
        model_spec <- substr(model_spec[2],1, 23)
        
        ##Criterios de model_info
        data <- capture.output(summary(arima_model))
        data <- data[grepl("AIC", data) == T]
        model_info <- strsplit(data, " ")
        pos <- which(sapply(model_info, nchar)>0)
        model_info <- model_info[[1]][pos]
        model_info <- do.call("rbind", strsplit(model_info, "=")) %>% 
            data.frame() 
        colnames(model_info) <- c("Medida", "Valor")
        model_info <- model_info %>% 
            mutate(Valor = as.numeric(as.character(Valor))) %>% 
            spread(Medida, Valor) %>% 
            data.frame(arima_model = model_spec)
        
        ##final_measures de model_performance
        model_performance <- data.frame(arima_model = c(model_spec, paste(model_spec, "Validacion")), 
                                        accuracy(forecast(arima_model, horizon, xreg = regr), testing))
        merge(model_info, model_performance, by="arima_model", all = TRUE) %>% 
            select(arima_model, AIC, AICc, BIC, MAE, RMSE, MASE)
    }
    ############################################################################################
    
    arima_selected <- function(model_table, Wtrain=training_weight, Wtest=testing_weight){
        
        #Elimina posibles arima_models duplicados
        model_table <- model_table %>%
            distinct(arima_model, .keep_all = TRUE)
        
        #Crea variable para agrupar arima_models en train y test
        model_table <- model_table %>% 
            mutate(mod = as.character(c(0, rep(1:(nrow(model_table)-1)%/%2))))
        
        #Crea la variable de puntaje ponderado
        tabla2 <- model_table %>% 
            mutate_at(vars(contains("C")), function(x){x-min(x, na.rm=TRUE)}) %>% 
            mutate_if(is.numeric, function(x) ifelse(is.na(x),0,x)) %>% 
            mutate(puntaje = AIC+AICc+BIC+MAE+RMSE+MASE,
                   ponde = ifelse(grepl("Validacion", arima_model)==TRUE, Wtest, Wtrain),
                   puntaje = puntaje*ponde)
        
        #Busca el(los) puntaje(s) mínimo(s)
        suppressMessages({
            minimal_score <- tabla2 %>% 
                group_by(mod) %>% 
                summarise(puntaje=sum(puntaje)) %>% 
                ungroup
        })
        
        #Obtiene la(s) posición(es) con puntaje(s) más bajo(s) 
        pos <- minimal_score$mod[which(minimal_score$puntaje==min(minimal_score$puntaje))]
        
        #Devuelve el(los) mejor(es) arima_model(s)
        model_table %>% 
            filter(mod %in% pos) %>% 
            dplyr::select(arima_model:MASE)
    }
    
    ############################################################################################
    suppressWarnings({     
        #Matriz para la identificacion de los parametros del arima_model
        valores <- expand.grid(p = 0:arima_process[1], d = 0:arima_process[2], q = 0:arima_process[3], 
                               P = 0:arima_process[4], D = 0:arima_process[5], Q = 0:arima_process[6])
        
        non_seasonal_values <- split(as.matrix(valores[, 1:3]), 
                                     row(valores[, 1:3]))
        seasonal_values <- split(as.matrix(valores[, 4:6]), 
                                 row(valores[, 4:6]))
        
        #Estimación de los arima_models
        if(parallelize==FALSE){
            arima_models <- mapply(arima_model, 
                                   non_seasonal=non_seasonal_values, 
                                   seasonal=seasonal_values, 
                                   MoreArgs = list(time_serie=train, regr=reg, periodic=seasonal_periodicity), 
                                   SIMPLIFY = FALSE)
        }
        
        if(parallelize==TRUE){
            
            #Nombres de los objetos a exportar a cada cluster
            
            obj <- sapply(as.list(match.call()), paste)
            pos <- which(names(obj) %in% c("time_serie", "validacion"))
            
            #Generar los cluster
            clp <- makeCluster(clusters, type = "SOCK", useXDR=FALSE)
            clusterExport(clp, varlist = c(obj[pos], "arima_measures", "arima_model"))
            
            #Proceso en parallelize
            arima_models <- clusterMap(cl=clp, fun = arima_model, 
                                       non_seasonal=non_seasonal_values, 
                                       seasonal=seasonal_values, 
                                       MoreArgs = list(time_serie=train, regr=reg, periodic=seasonal_periodicity), 
                                       SIMPLIFY = FALSE, .scheduling = "dynamic")
            stopCluster(clp)
            
        }
        
        #Obtiene las posiciones de la lista donde se pudieron estimar los arima_models
        pos <- which(sapply(lapply(arima_models, class), length)>1)
        
        #Calcula las final_measures de model_performance y los criterios de información
        final_measures <- do.call("rbind", lapply(arima_models[pos], 
                                                  arima_measures, 
                                                  testing = test, 
                                                  horizon= horiz, 
                                                  regr = reg)) %>% 
            mutate_if(is.numeric, round, 2)
        #Devuelve una lista con los arima_models y las final_measures de model_performance
        final_list <- list(arima_models=arima_models[pos], 
             final_measures=final_measures, 
             bests=arima_selected(final_measures, Wtrain = training_weight, Wtest = testing_weight))
        
        mod_index <- final_list$bests %>% 
          row.names %>% 
          as.numeric %>% 
          floor %>% 
          unique %>% 
          as.character
        
        final_list$best_model <- eval(parse(text = paste0("final_list$arima_models$", "`", mod_index, "`")))
        
        final_list
        })
}

```

```{r}
comparacion <- function(data, proporcion, proceso, periodicidad, paralelo,...){
    require(parallel)
    require(tidyr)
    require(dplyr)
    corte <- round(length(data)*proporcion, 0)
    train <<- subset(data, end=corte)
    test <<- subset(data, start=corte+1)
    haa <- auto.arima(train)
    op <- op.arima(arima_process=proceso,
                       seasonal_periodicity = periodicidad,
                       time_serie = data,
                       horiz = 50,
                       prop = proporcion,
                       parallelize = paralelo)
    
    arima_estandar <- Arima(y = data,...)
    list(haa=haa, op=op, arima_estandar=arima_estandar)
}

comparacion_no_estacional_bajo <- lapply(resultados_no_estacional_bajo, function(x){
    res <- comparacion(data=x$datos, 
                 proporcion = .8, 
                 proceso=c(6,1,6,0,0,0),
                 periodicidad = 1,
                 paralelo = FALSE,
                 order = c(1,1,1),
                 seasonal = c(0,0,0))
    list(modelos=list(original = x$modelo,
                      autoarima = res$haa,
                      sobreparametrizacion = res$op$best_model,
                      arima_estandar = res$arima_estandar),
         resultados_sobreparametrizacion = res$op[1:2])
    
    
})

comparacion_no_estacional_alto <- lapply(resultados_no_estacional_alto, function(x){
    res <- comparacion(data=x$datos, 
                 proporcion = .8, 
                 proceso=c(6,1,6,0,0,0),
                 periodicidad = 1,
                 paralelo = FALSE,
                 order = c(1,1,1),
                 seasonal = c(0,0,0))
    list(modelos=list(original = x$modelo,
                      autoarima = res$haa,
                      sobreparametrizacion = res$op$best_model,
                      arima_estandar = res$arima_estandar),
         resultados_sobreparametrizacion = res$op[1:2])
    
    
})

comparacion_estacional_bajo <- lapply(resultados_estacional_bajo, function(x){
    res <- comparacion(data=x$datos, 
                 proporcion = .8, 
                 proceso=c(6,1,6,6,1,6),
                 periodicidad = 12,
                 paralelo = TRUE,
                 order = c(1,1,1),
                 seasonal = c(1,1,1))
    list(modelos=list(original = x$modelo,
                      autoarima = res$haa,
                      sobreparametrizacion = res$op$best_model,
                      arima_estandar = res$arima_estandar),
         resultados_sobreparametrizacion = res$op[1:2])
    
    
})

comparacion_estacional_alto <- lapply(resultados_estacional_alto, function(x){
    res <- comparacion(data=x$datos, 
                 proporcion = .8, 
                 proceso=c(6,1,6,6,1,6),
                 periodicidad = 12,
                 paralelo = TRUE,
                 order = c(1,1,1),
                 seasonal = c(1,1,1))
    list(modelos=list(original = x$modelo,
                      autoarima = res$haa,
                      sobreparametrizacion = res$op$best_model,
                      arima_estandar = res$arima_estandar),
         resultados_sobreparametrizacion = res$op[1:2])
    
    
})

comparacion_no_estacional_bajo[[1]]$modelos

resultados_no_estacional_bajo
```

