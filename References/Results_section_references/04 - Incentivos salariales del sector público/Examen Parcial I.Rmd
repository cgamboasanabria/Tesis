---
title: "Examen Parcial I"
author: "César Gamboa Sanabria - Stefany Matarrita Muñoz"
date: "30 de septiembre de 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, cache=TRUE)
```

```{r, results='hide', echo=FALSE}
requeridos <- function(paq){
  paq.nuevo <- paq[!(paq %in% installed.packages()[, "Package"])]
  if (length(paq.nuevo)) 
    install.packages(paq.nuevo, dependencies = TRUE)
  sapply(paq, require, character.only = TRUE)
}

paquetes <- c("readxl", "ggpmisc", "ggplot2", "lubridate", "ggseas", 
              "forecast", "xtable", "seasonal", "tidyr", "MASS",
              "formattable", "dplyr")

requeridos(paquetes)
```


## Preguntas teóricas.   

### 1. 

La razón principal es que estos métodos utilizan los datos observados de la serie para estimar los coeficientes de una ecuación, minimizando el error resultante de la diferencia de los valores observados y estimados. Con la ecuación se puede pronosticar los valores futuros de la serie asignándole un cierto nivel de confianza al valor pronosticado. Un ejemplo de este concepto es la ecuación de regresión longitudinal:

$$y_t = \beta_0 + \beta_1 t + \epsilon_t$$

### 2. 

La sección de entrenamiento sirve para estimar el o los modelos.
La de validación para estimar los valores de la serie del set de validación con el o los modelos obtenido(s). 
Tanto el set de entrenamiento como el de validación sirve para determinar que tan bien ajusta el modelo a los datos observados mediante medidas de rendimiento.

La relación con el pronóstico es que con los pasos anteriores se encuentra el mejor modelo (el que mejor ajusta a la serie), y con éste es que se pronostica con un horizonte h.

### 3. 

El principio de no la redundancia consiste en que cuándo se tienen predictores categóricas con k categorías como lo es en el caso de la estacionalidad,  solo se necesitan k-1 variables dummies para codificar esta variable, ya que la categoría que se queda por fuera es cuando el resto de dummies toman el valor de cero.
Interpretación asumiendo que es la serie de ventas:

En promedio las “ventas” disminuyen en 81.0 unidades en el II trimestre respecto al I trimestre.
En promedio las “ventas” disminuyen en 27.7 unidades en el III trimestre respecto al I trimestre.
En promedio las “ventas” aumentan en 12.3 unidades en el IV trimestre respecto al I trimestre.

### 4. 

Por definición la media móvil viene dada por la ecuación (1), donde $k=\frac{m-1}{2}$ y los pesos $a_{-k},\cdots, a_k$ suman $1$

\begin{equation}
\hat {y_t}=\sum_{j=-k}^k a_j\cdot y_{t+j}
\end{equation}

La media móvil centrada en $\pm k$ datos es un caso particular donde la $m=(s+1)$, y los pesos vienen dados por $\frac{1}{s}$ a excepción de las colas donde los pesos vienen dados por $\frac{1}{2s}$. De esta manera, si $s=4$ entonces $k=\frac{(s+1)-1}{2}=\frac{4}{2}=2$, y

$$\hat{y_t}=\frac{1}{8}y_{t-2}+\frac{1}{4}y_{t-1}+\frac{1}{4}y_t+\frac{1}{4}y_{t+1}+\frac{1}{8}y_{t+2}$$

$$=\frac{\frac{1}{2}y_{t-2}+y_{t-1}+y_t+y_{t+1}+\frac{1}{2}y_{t+2}}{4}$$

Y como se puede observar el resultado de esa equivalencia es la definición de las medias móviles centradas en $\pm k$, para una serie de periodicidad 4.Nótese que se sigue cumpliendo que los pesos suman 1 y que además son simétricos.

### 5. 

No se considera correcto ya que la tendencia por definición no es lo mismo que ciclo, y por ende también sus análisis deben ser diferentes. La tendencia corresponde a un movimiento creciente o decreciente sostenido en un intervalo de tiempo, mientras que los ciclos corresponden a fluctuaciones en forma sinusoidal en períodos mayores a un año y para analizarlos se requiere una gran cantidad de datos, entonces si cuentan con pocos datos y se considera la tendencia ciclo como un solo componente se puede estar cometiendo un grave error a la hora de interpretarlos conjuntamente.

Dado lo anterior se considera los análisis de descomposición no son pertinentes, principalmente porque la mayoría de métodos de descomposición utilizan las medias móviles para estimar el componente tendencia-ciclo, y se sabe que con órdenes m altos, las medias móviles quitan el efecto de la estacionalidad, los efectos aleatorios e inclusive los ciclos.

### 6. 

* Porque se puede utilizar la media móvil o algunos de los componentes de la serie como los “datos observados” y aplicarle un método de estimación para luego pronosticar sus valores futuros.

* Con el análisis descriptivo de se pueden obtener valores ajustados.

* El componente de tendencia-ciclo y estacionalidad.

### 7. 

$$\hat y_{t+1}=0.5y_t+(1-0.5)\hat y_t$$

$$\hat y_{t+2}=0.5y_{t+1}+(1-0.5)\hat y_{t+1}$$

$$\hat y_{t+3}=0.5y_{t+2}+(1-0.5)\hat y_{t+2}$$

$$\hat y_{t+4}=0.5y_{t+3}+(1-0.5)\hat y_{t+3}$$

$$\hat y_{t+5}=0.5y_{t+4}+(1-0.5)\hat y_{t+4}$$

### 8.

$\alpha$, $\beta$ y $\gamma$ son parámetros de suavizamiento para el nivel, la tendencia y la estacionalidad respectivamente.

Estos parámetros no se deben interpretar ya que estos parámetros de suavizamiento son simplemente ponderadores que indican qué se le da más peso al momento de estimar el componente de nivel, tendencia y estacional.


### 9.

La ecuación de mejor ajuste se puede expresar de modo matricial de la siguiente manera:

$$
\begin{bmatrix}
y_1 \\
y_2 \\
\vdots \\
y_t \\
\vdots \\
y_T
\end{bmatrix} = \begin{bmatrix}
1 & x_{1,1} & x_{2,1} & \cdots & x_{k,1} \\
1 & x_{1,2} & x_{2,2} & \cdots & x_{k,2} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & x_{1,t} & x_{2,t} & \cdots & x_{k,t} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
1 & x_{1,T} & x_{2,T} & \cdots & x_{k,T} \\
\end{bmatrix} \begin{bmatrix}
\beta_1 \\
\beta_2 \\
\vdots \\
\beta_t \\
\vdots \\
\beta_T
\end{bmatrix} + \begin{bmatrix}
\varepsilon_1 \\
\varepsilon_2 \\
\vdots \\
\varepsilon_t \\
\vdots \\
\varepsilon_T
\end{bmatrix}
\Rightarrow Y = X \beta + \varepsilon
$$


Para encontrar los estimadores de máxima verosimilitud, se parte del supuesto de que los datos de la serie condicionado a los parámetros tienen una distribución normal, por ende al desarrollar la función de verosimilitud se obtiene:


$$
\begin{aligned}
L & = \prod\limits_{i=1}^T f(y_i | x_i, \beta, \sigma^2) \\
& = \prod\limits_{i=1}^T \left(2\pi \sigma^2 \right)^{-1/2} exp\left( {\frac{-1}{2} \left(\frac{y_i - x_i \beta}{\sigma} \right)^2} \right) \\
& = \left(2 \pi \sigma^2 \right)^{-T/2} exp \left( {\frac{-1}{2 \sigma^2} \sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2} \right) \\
& = \left(2 \pi \sigma^2 \right)^{-T/2} exp \left(\frac{-1}{2 \sigma^2} \left(Y - X \beta \right)^\top \left(Y - X \beta \right) \right) \\
& = \left(2 \pi \sigma^2 \right)^{-T/2} exp \left(\frac{-1}{2 \sigma^2} \varepsilon^\top \varepsilon \right)
\end{aligned}
$$

Para facilitar la derivación y encontrar los parámetros que maximizan esa función, se obtiene el log de la verosimilitud:

$$
\begin{aligned}
\ell & = \ln(L) \\
& = \ln\left(\left(2 \pi \sigma^2 \right)^{-T/2} exp \left( {\frac{-1}{2 \sigma^2} \sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2} \right) \right) \\
& = \ln\left(\left(2 \pi \sigma^2 \right)^{-T/2} \right) + \ln\left(exp \left( {\frac{-1}{2 \sigma^2} \sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2} \right) \right) \\
& = \frac{-T}{2} \ln(2\pi) + \frac{-T}{2} \ln(\sigma^2) + \frac{-1}{2 \sigma^2} \left(\sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 \right)
\end{aligned}
$$

Para poder obtener los $\beta$ que maximizan el log de la verosimilitud, necesitamos calcular la derivada de la $\ell$ con respecto a $\beta$:

$$
\begin{aligned}
\frac{\partial \ell}{\partial \beta} & = \left(\frac{-T}{2} \ln(2\pi) \right)^\prime + \left(\frac{-T}{2} \ln(\sigma^2) \right)^\prime + \left(\frac{-1}{2 \sigma^2} \left(\sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 \right) \right)^\prime \\
& = 0 + 0 +\frac{-1}{2 \sigma^2} \sum\limits_{i=1}^T \left(\left(y_i - x_i \beta \right)^2 \right)^\prime \\
& = \frac{-1}{2 \sigma^2} \sum\limits_{i=1}^T \left(-x_i^\top 2 \left(y_i - x_i \beta \right) \right) \\
& = \frac{1}{\sigma^2} \sum\limits_{i=1}^T \left(x_i^\top\left(y_i - x_i \beta \right) \right)
\end{aligned}
$$

Para encontrar el máximo, se iguala la derivada a 0 y se despeja $\beta$:

$$
\begin{aligned}
& \frac{\partial \ell}{\partial \beta} = 0 \\
\Rightarrow & \frac{1}{\sigma^2} \sum\limits_{i=1}^T \left(x_i^\top\left(y_i - x_i \beta \right) \right) =  0 \\
\Rightarrow & \sum\limits_{i=1}^T x_i^\top y_i - \sum\limits_{i=1}^T x_i^\top x_i \beta = 0 \\
\Rightarrow & \sum\limits_{i=1}^T x_i^\top y_i =  \beta \sum\limits_{i=1}^T x_i^\top x_i \\
\Rightarrow & \left( \sum\limits_{i=1}^T x_i^\top x_i \right)^{-1} \sum\limits_{i=1}^T x_i^\top y_i =  \beta \\
\Rightarrow & \left(X^\top X \right)^{-1} X^\top Y = \beta
\end{aligned}
$$

El estimador de máxima verosimilitud para $\beta$ es $\left(X^\top X \right)^{-1} X^\top Y$. 

Para encontrar el estimador $\sigma^2$ se calcula la derivada de la función de log-verosimilitud con respecto a $\sigma^2$:

$$
\begin{aligned}
\frac{\partial \ell}{\partial \sigma^2} & = \left(\frac{-T}{2} \ln(2\pi) \right)^\prime + \left(\frac{-T}{2} \ln(\sigma^2) \right)^\prime + \left(\frac{-1}{2 \sigma^2} \left(\sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 \right) \right)^\prime \\
& = 0 + \frac{-T}{2 \sigma^2} + \frac{-1}{2} \left(\sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 \right) \left(\frac{1}{\sigma^2} \right)^\prime \\ 
&= \frac{-T}{2 \sigma^2} + \frac{-1}{2} \left(\sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 \right) \left(\frac{-1}{\left( \sigma^2 \right)^2} \right) \\
& = \frac{1}{2 \sigma^2} \left(\frac{1}{\sigma^2 } \sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 - T \right)
\end{aligned}
$$

Ahora, para encontrar el máximo, necesitamos igualar la derivada a 0 y despejar $\sigma^2$:

$$
\begin{aligned}
& \frac{\partial \ell}{\partial \sigma^2} = 0 \\
\Rightarrow & \frac{1}{2 \sigma^2} \left(\frac{1}{\sigma^2 } \sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 - T \right) = 0 \\
\Rightarrow & \frac{1}{\sigma^2 } \sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 - T = 0\\
\Rightarrow & \frac{1}{\sigma^2 } \sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2 = T \\
\Rightarrow & \frac{\sum\limits_{i=1}^T \left(y_i - x_i \beta \right)^2}{T} = \sigma^2 \\
\Rightarrow & \frac{\left(Y - X \beta \right)^\top \left(Y - X \beta \right)}{T} = \frac{\varepsilon^\top \cdot \varepsilon}{T} = \sigma^2
\end{aligned}
$$

## Preguntas prácticas

### 1.

```{r, results='hide'}
base <- read_excel("C:\\Users\\Dell\\OneDrive\\Academico\\Proyectos\\GitHub\\Academico\\Cursos\\SP-1633 Series Cronológicas\\Examenes\\Parcial I\\Datos examen1.xlsx")
train <- base %>% 
  filter(Fecha<"2016-06-01")
train <- ts(train$`Incentivos salariales`, start = c(2007, 1), frequency = 12)
train.serie <- window(train, 2007)
test <- base %>% 
  filter(Fecha>"2016-06-01")
test <- ts(test$`Incentivos salariales`, start = c(2016, 7), frequency = 12)
test.serie <- window(test, c(2016, 7))
TS <- ts(base$`Incentivos salariales`, start = c(2007, 1), end = c(2018, 6), frequency = 12)
```

##### a.   

Incentivo salarial: Retribuciones que de conformidad con la legislación vigente se asignan al servidor por sus características laborales que complementan las remuneraciones básicas. Los incentivos se reconocen tanto a profesionales como a no profesionales, facultados por disposiciones jurídicas que así lo autorizan. Algunos de estos incentivos son: anualidades, dedicación exclusiva, salario escolar, carrera profesional, carrera técnica, zonaje, desarraigo, regionalización, riesgo policial, riesgo penitenciario, riesgo de seguridad y vigilancia, peligrosidad,  incentivo didáctico...

Esta serie representa los incentivos salariales en millones de colones del sector público de Costa Rica de enero 2007 a junio 2018.

\newpage

##### b.     

```{r, results='hold'}
ggplot(TS)+
  geom_line(color = "#00AFBB", size = 1.3) +
  stat_smooth(color = "#FC4E07", fill = "#FC4E07",
              method = "loess")+
  geom_vline(xintercept = 2008.6, linetype="dashed", color = "red")+
  theme_minimal() +
  theme(text = element_text(size=9),
        axis.text.x = element_text(angle=0, hjust=1)) +
  ggtitle("Gráfico 1: Incentivos salariales en el sector público 2007 - 2018") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos (millones de colones)",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  #ylim(7,12) +
  scale_x_discrete(expand = c(0,0), limits=c(2008, 2011, 2014, 2018))
```

En el gráfico 1, al hacer un suavizamiento Loess hay un ligero cambio de concavidad a partir de Julio 2008, lo cual sugiere que a partir de este momento los incentivos salariales vuelvan a alcanzar valores similares a los mostrados al inicio de la serie.


```{r, fig.height=4.3, fig.width=6.6, fig.align='center'}
base %>% 
  group_by(año=year(Fecha), mes=month(Fecha, label = TRUE, abbr=FALSE)) %>% 
  summarise(`Incentivos salariales`) %>% 
 # mutate(mes=factor(mes, labels=c("Febrero - Enero", "Marzo - Febrero",
  #                                "Abril - Marzo", "Mayo - Abril", 
   #                               "Junio - Mayo", "Julio - Junio",
    #                              "Agosto - Julio", "Setiembre - Agosto",
     #                             "Octubre - Setiembre", "Noviembre - Octubre",
      #                            "Diciembre - Noviembre", "Enero - Diciembre"))) %>% 
  ggplot(., aes(x=año, y=`Incentivos salariales`)) +
  facet_wrap(.~mes, ncol=3) +
  geom_line(color = "#00AFBB", size = 1.3) +
  #stat_peaks(colour = "red") +
  #stat_peaks(geom = "text", colour = "red", 
    #         vjust = -0.5) +
  #stat_valleys(colour = "blue") +
  #stat_valleys(geom = "text", colour = "blue", angle = 20,
   #            vjust = 0.1, hjust = 1) +
  theme_minimal() +
  theme(text = element_text(size=13),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12)) +
  ggtitle("Gráfico 2: Incentivos salariales en el sector público 2007 - 2018 según mes") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos (millones de colones)",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
 # ylim(7, 14) +
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

El gráfico 2 muestra cómo hay un crecimiento sostenido de los incentivos en cada mes a lo largo de todo el periodo. Sin embargo, este crecimiento se da a una tasa mucho mayor en la época de fin y principio de año.

```{r}
base %>% 
  mutate(`Incentivos salariales`=BoxCox(`Incentivos salariales`, lambda=1)) %>% 
ggsdc(., aes(x = Fecha, y = `Incentivos salariales`),
         method = "stl", s.window = 7, frequency = 12, type="multiplicative",
         facet.titles = c("Serie Original", "Tendencia", 
                          "Estacionalidad", "Aleatoria")) +
      geom_line(color = "#00AFBB", size = 1.3) +
  labs(x = "", y = "") +
  theme_minimal() +
  theme(text = element_text(size=13),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12)) +
  ggtitle("Gráfico 3: Descomposición de la serie de Incentivos\nsalariales en el periodo 2007 - 2018") +
  labs(caption="Fuente: SIGAF") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  scale_x_discrete(expand = c(0,0))
```

En el gráfico 3 se muestra la descomposición de la serie en sus distintos componentes. Pueden observarse, además de un crecimiento a lo largo del tiempo, los picos y las caídas en la parte estacional, esto hace referencia a los meses de Diciembre y Enero; cuando no se está en este periodo los incentivos poseen un comportamiento más estable. El componente aleatorio muestra indicios de que la varaibilidad de la serie no es homogénea, sino que cambia conforme pasa el tiempo.

\newpage

##### c.

```{r}
data.frame(MMC=ma(TS, order=6), Serie=TS, fecha=base$Fecha) %>% 
  gather(Tipo, valor, -fecha) %>% 
  ggplot(., aes(x=fecha, y=valor, colour=Tipo))+
  geom_line(size=1.3)+
  #theme_minimal() +
  theme(text = element_text(size=9),
      axis.text.x = element_text(angle=0, hjust=1),
        legend.title=element_blank()) +
  ggtitle("Gráfico 4: Media móvil centrada de orden 6") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos salariales",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                margin=margin(t=1,10,10,10))) 
  #ylim(7,12) 
  #scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

Al ajustar un procedimiento de medias móviles de orden 6 puede verse el crecimiento sostenido de la serie de incentivos económicos a lo largo del tiempo, siendo en promedio mayor en los meses de enero y diciembre. 

\newpage

##### d.

```{r}
#dummy <- ifelse(train.serie>100000, 1, 0)
mod1 <- tslm(train.serie ~ trend)
mod2 <- tslm(train.serie ~ trend + season)
mod3 <- tslm(train.serie ~ trend + season, lambda = 0)
#mod3 <- tslm(train.serie ~ trend + season + fourier(train.serie, K=6))
```

* Modelo con tendencia:

$$\hat y_t=21579.8+521.9\cdot t; \text{donde t es la tendencia}$$
* Modelo con tendencia y estacionalidad


$$
\begin{aligned}
\hat y_t= 85147.6+518.6t-81644.9s_2-79202.6s_3-79054.2s_4-77335.4s_5-66784.2s_6\\
-78252.5s_7-78101.2s_8-75124.6s_9-78537.6s_9-78537.6s_{10}-78404.7s_{11}+12369.5s_{12}
\end{aligned}
$$
* Modelo con ajuste exponencial

$$
\begin{aligned}
log\left(\hat y_t\right)=10.95114+0.01115t-1.26910s_2-1.18415s_3-1.17571s_4-1.13261s_5-0.87959s_6\\
-1.15689s_7-1.15163s_8-1.03860s_9-1.15291s_{10}-1.13623s_{11}+0.08372s_{12}
\end{aligned}
$$

```{r}
medidas1 <- function(modelo, tipo){
  data.frame(Modelo=tipo, 
             medida=CV(modelo)[2:4],
             tipo=names(CV(modelo)[2:4]))
}

informacion <- do.call("rbind", list(medidas1(mod1, "Tendencia"), 
                                     medidas1(mod2, "Tendencia + estacionalidad"),
                                     medidas1(mod3, "Exponencial"))) %>% 
  spread(tipo, medida)
```

```{r}
medidas2 <- function(modelo, horizonte, clase){
  accuracy(forecast(modelo, h=12), 
                test.serie)[, c("MAE", "MAPE", "RMSE", "MASE")] %>% 
  data.frame(Modelo=c(clase, paste(clase, "en Validacion")))
}

rendimiento <- do.call("rbind", list(medidas2(mod1, 12, "Tendencia"),
                                     medidas2(mod2, 12, "Tendencia + estacionalidad"),
                                     medidas2(mod3, 12, "Exponencial")))
```

```{r}
criterios <- merge(informacion, rendimiento, by="Modelo", all = TRUE) %>% 
  mutate_if(is.numeric, function(x){round(x, 3)}) %>% 
  mutate(AIC=ifelse(is.na(AIC), "", round(AIC, 3)),
         BIC=ifelse(is.na(BIC), "", round(BIC, 3)),
         AICc=ifelse(is.na(AICc), "", round(AICc, 3)))

tabla <- function(datos, set){
  
  if(set=="entrenamiento"){
    datos <- datos %>% 
      filter(!grepl("Validacion", levels(Modelo)))
    cuadro <- formattable(datos, align=c("l", "r", "r", "r", "r", "r", "r", "r"),
                list(Modelo = formatter("span",
                                        style = ~ style(color = "grey",
                                                        font.weight = "bold")),
                     AIC = formatter("span",
                                     style = x~ style(font.weight = "bold",
                                                      `border-radius` = "4px",
                                                      display = "block",
                                                      padding = "0 4px",
                                                      `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     AICc = formatter("span",
                                      style = x~ style(font.weight = "bold",
                                                       `border-radius` = "4px",
                                                       display = "block",
                                                       padding = "0 4px",
                                                       `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     BIC = formatter("span",
                                     style = x~ style(font.weight = "bold",
                                                      `border-radius` = "4px",
                                                      display = "block",
                                                      padding = "0 4px",
                                                      `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     MAE = formatter("span",
                                     style = x~ style(font.weight = "bold",
                                                      `border-radius` = "4px",
                                                      display = "block",
                                                      padding = "0 4px",
                                                      `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     MAPE = formatter("span",
                                      style = x~ style(font.weight = "bold",
                                                       `border-radius` = "4px",
                                                       display = "block",
                                                       padding = "0 4px",
                                                       `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     RMSE = formatter("span",
                                      style = x~ style(font.weight = "bold",
                                                       `border-radius` = "4px",
                                                       display = "block",
                                                       padding = "0 4px",
                                                       `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     MASE = formatter("span",
                                      style = x~ style(font.weight = "bold",
                                                       `border-radius` = "4px",
                                                       display = "block",
                                                       padding = "0 4px",
                                                       `background-color` = ifelse(x==min(x), "skyblue", "white")))))
  }
  
  if(set=="validacion"){
    datos <- datos %>% 
      filter(grepl("Validacion", levels(Modelo))) %>% 
      select(Modelo, MAE, MAPE, RMSE, MASE)
    cuadro <- formattable(datos, align=c("l", "r", "r", "r", "r"),
                list(Modelo = formatter("span",
                                        style = ~ style(color = "grey",
                                                        font.weight = "bold")),
                     MAE = formatter("span",
                                     style = x~ style(font.weight = "bold",
                                                      `border-radius` = "4px",
                                                      display = "block",
                                                      padding = "0 4px",
                                                      `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     MAPE = formatter("span",
                                      style = x~ style(font.weight = "bold",
                                                       `border-radius` = "4px",
                                                       display = "block",
                                                       padding = "0 4px",
                                                       `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     RMSE = formatter("span",
                                      style = x~ style(font.weight = "bold",
                                                       `border-radius` = "4px",
                                                       display = "block",
                                                       padding = "0 4px",
                                                       `background-color` = ifelse(x==min(x), "skyblue", "white"))),
                     MASE = formatter("span",
                                      style = x~ style(font.weight = "bold",
                                                       `border-radius` = "4px",
                                                       display = "block",
                                                       padding = "0 4px",
                                                       `background-color` = ifelse(x==min(x), "skyblue", "white")))))
  }
  cuadro
} 
```


De los tres modelos, en la figura 1 se observa que el que posee los valores más bajos en las medidas clásicas de error,es el modelo de regresión con la variante no lineal (exponencial), y también es éste modelo el que presenta las medidas de criterios de información  más cercanas a 0.

```{r, eval=FALSE}
tabla(criterios, "entrenamiento")
```

\newpage

![](C:\\Users\\Dell\\Desktop\\Imagenes\\1d.png)

##### e.

```{r, eval=FALSE}
tabla(criterios, "validacion")
```

Al hacer el pronóstico con los datos de validación, el modelo que presenta un mejor ajuste es el lineal que involucra tendencia y estacionalidad, el cual es el segundo mejor modelo si se consideran los datos de entrenamiento. Esto puede verse en la siguiente figura.

![](C:\\Users\\Dell\\Desktop\\Imagenes\\1e.png)
\newpage
  
##### f.

```{r}
serie.completa <- window(TS, start=2007)
modfinal <- tslm(serie.completa ~ trend + season)

modfinal %>% 
  forecast(h=24) %>%
  autoplot() +
  theme_minimal() +
  theme(text = element_text(size=9),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12))+
  labs(fill = "Nivel de confianza")+
  autolayer(fitted(modfinal), serie="Ajustados") +
  ggtitle("Gráfico 5: Pronóstico de la serie de Incentivos\nsalariales en el periodo 2007 - 2018") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  #ylim(7,12) +
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

```{r, eval=FALSE}
forecast(modfinal, h=24)
```

\begin{table}[!ht]
\centering
\begin{tabular}{rrrrrr}
  \hline
 & Pronostico & LI 80 & LS 80 & LI 95 & LS 95 \\ 
  \hline
Jul 2018 & 71229.09 & 67430.56 & 75027.63 & 65419.74 & 77038.45 \\ 
  Ago 2018 & 70763.01 & 66958.63 & 74567.39 & 64944.71 & 76581.31 \\ 
  Sep 2018 & 71267.06 & 67456.82 & 75077.31 & 65439.80 & 77094.33 \\ 
  Oct 2018 & 71718.50 & 67902.39 & 75534.62 & 65882.26 & 77554.75 \\ 
  Nov 2018 & 72280.88 & 68458.88 & 76102.89 & 66435.64 & 78126.13 \\ 
  Dic 2018 & 126061.01 & 122233.11 & 129888.91 & 120206.74 & 131915.27 \\ 
  Ene 2019 & 72101.52 & 68267.71 & 75935.33 & 66238.21 & 77964.82 \\ 
  Feb 2019 & 72814.73 & 68974.99 & 76654.46 & 66942.36 & 78687.09 \\ 
  Mar 2019 & 74683.12 & 70837.45 & 78528.78 & 68801.68 & 80564.56 \\ 
  Abr 2019 & 75839.49 & 71987.88 & 79691.10 & 69948.96 & 81730.02 \\ 
  May 2019 & 74900.65 & 71043.08 & 78758.22 & 69001.01 & 80800.29 \\ 
  Jun 2019 & 75098.22 & 71234.68 & 78961.75 & 69189.44 & 81006.99 \\ 
  Jul 2019 & 75457.32 & 70533.14 & 80381.51 & 67926.44 & 82988.21 \\ 
  Ago 2019 & 74991.24 & 70062.35 & 79920.14 & 67453.15 & 82529.33 \\ 
  Sep 2019 & 75495.30 & 70561.68 & 80428.91 & 67949.98 & 83040.61 \\ 
  Oct 2019 & 75946.73 & 71008.38 & 80885.09 & 68394.17 & 83499.29 \\ 
  Nov 2019 & 76509.12 & 71566.01 & 81452.22 & 68949.29 & 84068.94 \\ 
  Dic 2019 & 130289.24 & 125341.38 & 135237.10 & 122722.14 & 137856.34 \\ 
  Ene 2020 & 76329.75 & 71377.11 & 81282.38 & 68755.35 & 83904.15 \\ 
  Feb 2020 & 77042.96 & 72085.54 & 82000.37 & 69461.24 & 84624.67 \\ 
  Mar 2020 & 78911.35 & 73949.13 & 83873.56 & 71322.29 & 86500.40 \\ 
  Abr 2020 & 80067.72 & 75100.69 & 85034.74 & 72471.31 & 87664.13 \\ 
  May 2020 & 79128.88 & 74157.03 & 84100.73 & 71525.10 & 86732.66 \\ 
  Jun 2020 & 79326.45 & 74349.77 & 84303.13 & 71715.27 & 86937.62 \\ 
   \hline
\end{tabular}
\end{table}

El pronóstico a 24 meses con el modelo lineal con tendencia y estacionalidad logra capturar de buena manera las subidas y bajadas que se dan en fin y principio de año, incluso se logra ajustar un nivel moderadamente aceptable del crecimiento constante de la serie en cuanto a sus valores máximos en comparación a los periodos anteriores.

\newpage

##### g.

```{r}
PIBreal <- read_excel("C:\\Users\\Dell\\OneDrive\\Academico\\Proyectos\\GitHub\\Academico\\Cursos\\SP-1633 Series Cronológicas\\Examenes\\Parcial I\\PIB Real.xlsx", sheet=2) %>% 
  mutate(año=year(año))
base %>% 
  group_by(año=year(Fecha)) %>% 
  summarise(incentivos=sum(`Incentivos salariales`)) %>% 
  merge(., PIBreal, by="año") %>% 
  mutate(incentivos=log(incentivos), PIB=log(PIB)) %>% 
  gather(tipo, valor, -año) %>% 
  #mutate(porcentaje=round(suma/PIB*100, 2)) %>% 
  ggplot(., aes(x=año, y=valor, colour=tipo))+
  geom_line(size=1.3)+
  theme_minimal() +
  theme(text = element_text(size=9),
      axis.text.x = element_text(angle=0, hjust=1),
        legend.title=element_blank()) +
  ggtitle("Gráfico 6: Crecimiento del logarítmo PIB y los incentivos\nsalariales en Costa Rica 2007-2017") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos salariales/PIB (escala logarítmica)",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                margin=margin(t=1,10,10,10))) +
  #ylim(7,12) 
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))

```

El gráfico 6 muestra el crecimiento del PIB y de los Incentivos salariales en escala logarítmica, pues de esta manera es más sencillo visualizar la tasa de cambio entre ambos. Puede observarse como los incentivos salariales crecen a un ritmo más acelerado que el PIB.

\newpage

### 2.

```{r}
base <- read_excel("C:\\Users\\Dell\\OneDrive\\Academico\\Proyectos\\GitHub\\Academico\\Cursos\\SP-1633 Series Cronológicas\\Examenes\\Parcial I\\Datos examen1.xlsx", sheet = 2)
```

##### a.

Amortización: Como parte de la deuda pública, la partida de amortización comprende las sumas destinadas a cubrir el pago de las obligaciones adquiridas con terceras personas físicas o jurídicas, del sector privado o del sector público, residentes en el territorio nacional o en el exterior, por los conceptos de emisión y colocación de títulos valores, contratación de préstamos directos, y otros como avales otorgados y créditos de proveedores. Incluye el pago de deudas contraídas por la institución, derivadas de otras obligaciones que no provienen de las actividades normales de financiamiento.

Esta serie representa la amortización en millones de colones del sector público de Costa Rica de enero 2007 a junio 2018.


##### b.

```{r, results='hide'}
base <- base %>%
  mutate(Amortización=ifelse(is.na(Amortización), 
                             mean(base$Amortización[month(base$Fecha)=="1"], na.rm = TRUE),
                             Amortización))
filter(base, month(base$Fecha) %in% 1)
```

Se muestran los valores de todos los eneros que se imputaron.

\begin{table}[ht]
\centering
\begin{tabular}{rlr}
  \hline
 & Fecha & Amortización \\ 
  \hline
 & 2007-01-01 & 239553.34 \\ 
   & 2008-01-01 & 239553.34 \\ 
   & 2009-01-01 & 103892.06 \\ 
   & 2010-01-01 & 211799.37 \\ 
   & 2011-01-01 & 154156.42 \\ 
   & 2012-01-01 & 238419.75 \\ 
   & 2013-01-01 & 217597.85 \\ 
   & 2014-01-01 & 125280.58 \\ 
   & 2015-01-01 & 281820.03 \\ 
   & 2016-01-01 & 158435.83 \\ 
   & 2017-01-01 & 334996.06 \\ 
   & 2018-01-01 & 569135.42 \\ 
   \hline
\end{tabular}
\end{table}

##### c.

```{r}
TS <- ts(base$Amortización, start = c(2007, 1), end = c(2018, 6), frequency = 12)
```
```{r, results='hold'}
ggplot(TS)+
  geom_line(color = "#00AFBB", size = 1.3) +
  stat_smooth(color = "#FC4E07", fill = "#FC4E07",
              method = "loess")+
  geom_vline(xintercept = c(2010.6, 2014.6), linetype="dashed", color = "red")+
  theme_minimal() +
  theme(text = element_text(size=9),
        axis.text.x = element_text(angle=0, hjust=1)) +
  ggtitle("Gráfico 6: Amortización en el sector público 2007 - 2018") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos (millones de colones)",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  #ylim(7,12) +
  scale_x_discrete(expand = c(0,0), limits=c(2008, 2011, 2014, 2018))
```

Al ajustar una regresión Loess para ver el comportamiento implícito de la serie, pueden apreciarse dos cambios de concavidad, uno aproximadamente en Junio del 2010 y el otro cerca de Julio del 2014 (líneas rojas punteadas). Una interpretación de estos cambios es que la amortización empezó a tener una leve tendencia a la baja a partir de mediados de año del 2010 (al pasar de cóncava hacia arriba a cóncava hacia abajo) para que luego, aproximadamente en Julio del 2014, la amortización volviera a experimentar un ascenso algo más pronunciado.

```{r, fig.align='center'}
base %>% 
  group_by(año=year(Fecha), mes=month(Fecha, label = TRUE, abbr=FALSE)) %>% 
  summarise(Amortización) %>% 
 # mutate(mes=factor(mes, labels=c("Febrero - Enero", "Marzo - Febrero",
  #                                "Abril - Marzo", "Mayo - Abril", 
   #                               "Junio - Mayo", "Julio - Junio",
    #                              "Agosto - Julio", "Setiembre - Agosto",
     #                             "Octubre - Setiembre", "Noviembre - Octubre",
      #                            "Diciembre - Noviembre", "Enero - Diciembre"))) %>% 
  ggplot(., aes(x=año, y=Amortización)) +
  facet_wrap(.~mes, ncol=3) +
  geom_line(color = "#00AFBB", size = 1.3) +
  stat_peaks(colour = "red") +
  stat_peaks(geom = "text", colour = "red", 
             vjust = -0.5) +
  stat_valleys(colour = "blue") +
  stat_valleys(geom = "text", colour = "blue", angle = 10,
               vjust = 0.1, hjust = 1) +
  theme_minimal() +
  theme(text = element_text(size=13),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12)) +
  ggtitle("Gráfico 7: Amortización en el sector público 2007 - 2018 según mes") +
  labs(caption="Fuente: SIGAF",
       y="Amortización",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
 # ylim(7, 14) +
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

La amortización muestra algunos picos y valles en ciertos meses, como por ejemplo dos valores particularmente altos en Junio del 2012 y del 2015.


```{r}
base %>% 
  #mutate(`Incentivos salariales`=BoxCox(`Incentivos salariales`, lambda=1)) %>% 
ggsdc(., aes(x = Fecha, y = Amortización),
         method = "stl", s.window = 7, frequency = 12, type="additive",
         facet.titles = c("Serie Original", "Tendencia", 
                          "Estacionalidad", "Aleatoria")) +
      geom_line(color = "#00AFBB", size = 1.3) +
  labs(x = "", y = "") +
  theme_minimal() +
  theme(text = element_text(size=13),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12)) +
  ggtitle("Gráfico 8: Descomposición de la serie de Amortización en el periodo 2007 - 2018") +
  labs(caption="Fuente: SIGAF") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  scale_x_discrete(expand = c(0,0))
```

Considerando la descomposición aditiva de la serie dada su estructura, puede verse una tendencia que, aunque con algunos bajas, generalmente crece con el tiempo. El componente estacional no parece algo determinante pues si bien al inicio de la serie luce algo más consistente, con el tiempo este comportamiento cambia y el efecto estacional parece diluirse. La variabilidad de la serie a lo largo del tiempo no luce homogénea, pues muestra bastantes cambios en cortos periodos de tiempo.

\newpage

##### d.

```{r}
data.frame(MMC=ma(TS, order=6, centre=TRUE), Serie=TS, fecha=base$Fecha) %>% 
  gather(Tipo, valor, -fecha) %>% 
  ggplot(., aes(x=fecha, y=valor, colour=Tipo))+
  geom_line(size=1.3)+
  #theme_minimal() +
  theme(text = element_text(size=9),
      axis.text.x = element_text(angle=0, hjust=1),
        legend.title=element_blank()) +
  ggtitle("Gráfico 9: Media móvil centrada de orden 6") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos salariales",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                margin=margin(t=1,10,10,10))) 
  #ylim(7,12) 
  #scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

Al aplicar una media móvil centrada de orden 6, se puede observar que en promedio el gasto de amortización ha ido en ascenso, siendo mayor en los meses de inicio y final de cada año.


\newpage

##### e.

```{r}
train <- base %>% 
  filter(Fecha<"2016-06-01")
train <- ts(train$Amortización, start = c(2007, 1), frequency = 12)
train.serie <- window(train, 2007)
test <- base %>% 
  filter(Fecha>"2016-06-01")
test <- ts(test$Amortización, start = c(2016, 7), frequency = 12)
test.serie <- window(test, c(2016, 7))
TS <- ts(base$Amortización, start = c(2007, 1), end = c(2018, 6), frequency = 12)
```


```{r}
modelos <- function(datos, errores){
  x <- c("N", errores, paste(errores, "d", sep=""))
  
  l <- list()
  for(i in 1:length(x)){
    l[[i]] <- paste(x[i], c("N", errores), sep="")
  }
  
  modelo <- unique(paste(errores, t(sapply(l, c))[1:15], sep=""))
  
  mods <- list()
  for( j in 1:length(modelo)){
    mods[[j]] <- if(!grepl("d", modelo[j]))
      {ets(datos, model=modelo[j])}else(ets(datos, model=gsub("d", "", modelo[j]), damped = TRUE))
  }
  mods

}
```


```{r}
mod1 <- modelos(train.serie, "A")[[1]]
mod2 <- modelos(train.serie, "A")[[5]]
mod3 <- hw(train.serie, model="AMM")
```

* Suavizamiento exponencial simple

$$
l_{t}=0.0001\cdot y_t+(1-0.0001)\cdot l_{t-1}\\
\hat y_{t+h|t}=l_{t}
$$

* Holt-Winters aditivo

$$
\begin{aligned}
\hat y_{t+h|t}=l_t+hb_t+s_{t+h-m(k+1)};donde\\
lt=0.0038(y_t-s_{t-m})+(1-0.0038)(l_{t-1}+b_{t-1})\\
bt=0.0001(l_t-l_{t-1})+(1-0.0001)b_{t-1}\\
s_t=0.0001(y_t-l_{t-1}-b_{t-1})+(1-0.0001)s_{t-m}
\end{aligned}
$$

* Holt-Winters multiplicativo

$$
\begin{aligned}
\hat y_{t+h|t}=(l_t+hb_t)s_{t+h-m(k+1)};donde\\
lt=0.0037\left(\frac{y_t}{s_{t-m}}\right)+(1-0.0037)(l_{t-1}+b_{t-1})\\
bt=0.0001(l_t-l_{t-1})+(1-0.0001)b_{t-1}\\
s_t=0.0001\left(\frac{y_t}{-l_{t-1}-b_{t-1}}\right)+(1-0.0001)s_{t-m}
\end{aligned}
$$

```{r}
f2 <- function(modelo, horizonte, testing){
  data <- capture.output(summary(modelo))
  mod <- gsub("ETS", "", data)[1]
  informacion <- sapply(strsplit(data[grep("BIC", data)+1], " "), as.numeric)[1:3]
  rendimiento <- sapply(strsplit(gsub("Training set ", "", data[length(data)]), " "), as.numeric)[1:7]
  entrena <- data.frame(medida=round(c(rendimiento, informacion), 4),
                        tipo=c("ME", "RMSE", "MAE", "MPE",
                               "MAPE", "MASE", "ACF1",
                               "AIC", "AICc", "BIC"),
                        Modelo=as.character(mod))
  
  pronos <- accuracy(forecast(modelo, h=horizonte), 
                     testing)[2, ]
  pronos <- data.frame(medida=round(pronos, 4), 
                       tipo=row.names(data.frame(pronos)),
                       Modelo=paste(levels(entrena$Modelo), "Validacion"))
  
  do.call("rbind", list(entrena, pronos))
}
```


```{r}
se <- lapply(list(mod1, mod2), f2, 24, test.serie) %>% 
  do.call("rbind", .) %>% 
  group_by(medida, tipo) %>% 
  filter(dplyr::row_number(Modelo)=="1",
         tipo %in% c("AIC", "AICc", "BIC", "RMSE", "MAE", "MAPE", "MASE")) %>% 
  spread(tipo, medida)

mhw <- data.frame(Modelo=c("Holt-Winters Multiplicativo", "Holt-Winters Multiplicativo Validacion"),
           AIC=c(3062.929, NA),
           AICc=c(3069.304, NA),
           BIC=c(3109.444, NA), 
           MAE=c(43604.99, 77195.97),
           MAPE=c(157.72260, 56.22557),
           MASE=c(0.7455645, 1.3199080),
           RMSE=c(55087.37, 115833.63))

medidas <- do.call("rbind", list(se, mhw))
medidas$Modelo <- c("Suavizamiento exponencial simple", "Suavizamiento exponencial simple en Validacion",
                    "Holt-Winters aditivo", "Holt-Winters aditivo en Validacion",
                    "Holt-Winters Multiplicativo", "Holt-Winters Multiplicativo en Validacion")
medidas$Modelo <- as.factor(medidas$Modelo)
```

```{r, eval=FALSE}
tabla(medidas, "entrenamiento")
```

![](C:\\Users\\Dell\\Desktop\\Imagenes\\2e.png)

En la figura 2 se muestran, para el conjunto de datos de entrenamiento, las medidas de rendimiento y las de criterio de información son practicamente idénticas, por lo que cualquiera de los dos modelos Holt-Winters son igual de ventajosos.

\newpage

##### f.

```{r, eval=FALSE}
tabla(medidas, "validacion")
```

De acuerdo a la figura 3 y de forma similar al apartado anterior, la diferencia en las medidas de rendimiento para los modelos Holt-Winters Aditivo y Multiplicativo es despreciable, por lo que se decide utilizar el Holt-Winters aditivo dada la estructura de la serie a lo largo del tiempo.

![](C:\\Users\\Dell\\Desktop\\Imagenes\\2f.png)

##### g.

```{r}
serie.completa <- window(TS, start=2007)
modfinal <- ets(serie.completa, model="AAA")
modfinal %>% 
  forecast(h=24) %>%
  autoplot() +
  theme_minimal() +
  theme(text = element_text(size=9),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12))+
  labs(fill = "Nivel de confianza")+
  autolayer(fitted(modfinal), serie="Ajustados") +
  ggtitle("Gráfico 7: Pronóstico de la serie de Amortización en el periodo 2007 - 2018\ncon el modelo HW aditivo") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  #ylim(7,12) +
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

```{r, eval=FALSE}
forecast(modfinal, h=24)
```

\begin{table}[ht]
\centering
\begin{tabular}{rrrrrr}
  \hline
 & Pronostico & LI 80 & LS 80 & LI 95 & LS 95 \\ 
  \hline
Jul 2018 & 75398.85 & 57031.47 & 93766.23 & 47183.68 & 103614.02 \\ 
  Ago 2018 & 74416.63 & 56049.26 & 92784.01 & 46201.47 & 102631.80 \\ 
  Sep 2018 & 77849.21 & 59481.83 & 96216.59 & 49634.04 & 106064.38 \\ 
  Oct 2018 & 76636.23 & 58268.85 & 95003.60 & 48421.06 & 104851.39 \\ 
  Nov 2018 & 75658.77 & 57291.39 & 94026.14 & 47443.60 & 103873.93 \\ 
  Dic 2018 & 176535.74 & 158168.36 & 194903.12 & 148320.57 & 204750.91 \\ 
  Ene 2019 & 162869.67 & 144530.81 & 181208.53 & 134698.31 & 191041.03 \\ 
  Feb 2019 & 74075.22 & 55736.37 & 92414.08 & 45903.86 & 102246.58 \\ 
  Mar 2019 & 76922.94 & 58584.08 & 95261.80 & 48751.58 & 105094.30 \\ 
  Apr 2019 & 77509.46 & 59170.60 & 95848.32 & 49338.10 & 105680.82 \\ 
  May 2019 & 79621.37 & 61282.51 & 97960.23 & 51450.01 & 107792.73 \\ 
  Jun 2019 & 88705.35 & 70366.49 & 107044.21 & 60533.99 & 116876.71 \\ 
  Jul 2019 & 81180.02 & 62742.22 & 99617.82 & 52856.67 & 109503.37 \\ 
  Ago 2019 & 80197.80 & 61760.00 & 98635.61 & 51874.45 & 108521.16 \\ 
  Sep 2019 & 83630.38 & 65192.58 & 102068.18 & 55307.03 & 111953.73 \\ 
  Oct 2019 & 82417.40 & 63979.59 & 100855.20 & 54094.04 & 110740.75 \\ 
  Nov 2019 & 81439.94 & 63002.13 & 99877.74 & 53116.58 & 109763.29 \\ 
  Dic 2019 & 182316.91 & 163879.11 & 200754.71 & 153993.56 & 210640.26 \\ 
  Ene 2020 & 168650.84 & 150236.03 & 187065.65 & 140362.81 & 196938.87 \\ 
  Feb 2020 & 79856.40 & 61441.59 & 98271.20 & 51568.37 & 108144.42 \\ 
  Mar 2020 & 82704.11 & 64289.30 & 101118.92 & 54416.08 & 110992.14 \\ 
  Abr 2020 & 83290.63 & 64875.82 & 101705.44 & 55002.60 & 111578.66 \\ 
  May 2020 & 85402.54 & 66987.74 & 103817.35 & 57114.52 & 113690.57 \\ 
  Jun 2020 & 94486.52 & 76071.71 & 112901.33 & 66198.49 & 122774.55 \\ 
   \hline
\end{tabular}
\end{table}

```{r}
serie.completa <- window(TS, start=2007)
modfinal <- hw(serie.completa, model="AMM")
modfinal %>% 
  forecast(h=24) %>%
  autoplot() +
  theme_minimal() +
  theme(text = element_text(size=9),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12))+
  labs(fill = "Nivel de confianza")+
  autolayer(fitted(modfinal), serie="Ajustados") +
  ggtitle("Gráfico 8: Pronóstico de la serie de Amortización en el periodo 2007 - 2018\ncon el modelo HW multiplicativo") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  #ylim(7,12) +
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

```{r, eval=FALSE}
forecast(modfinal, h=24)
```

\begin{table}[ht]
\centering
\begin{tabular}{rrrrrr}
  \hline
 & Pronostico & LI 80 & LS 80 & LI 95 & LS 95 \\ 
  \hline
Jul 2018 & 113080.74 & 20068.16 & 206093.33 & -29169.73 & 255331.22 \\ 
  Ago 2018 & 115036.84 & 22022.28 & 208051.41 & -27216.66 & 257290.35 \\ 
  Sep 2018 & 168828.42 & 75810.68 & 261846.16 & 26570.06 & 311086.77 \\ 
  Oct 2018 & 115651.62 & 22629.23 & 208674.02 & -26613.85 & 257917.10 \\ 
  Nov 2018 & 101957.79 & 8928.98 & 194986.59 & -40317.50 & 244233.07 \\ 
  Dic 2018 & 126840.41 & 33803.14 & 219877.68 & -15447.81 & 269128.63 \\ 
  Jan 2019 & 267655.22 & 174607.17 & 360703.27 & 125350.51 & 409959.93 \\ 
  Feb 2019 & 210494.54 & 117433.10 & 303555.98 & 68169.35 & 352819.72 \\ 
  Mar 2019 & 262941.89 & 169864.18 & 356019.60 & 120591.81 & 405291.97 \\ 
  Apr 2019 & 132235.93 & 39138.78 & 225333.08 & -10143.88 & 274615.74 \\ 
  May 2019 & 184961.69 & 91841.65 & 278081.74 & 42546.88 & 327376.51 \\ 
  Jun 2019 & 169488.96 & 76342.31 & 262635.62 & 27033.45 & 311944.48 \\ 
  Jul 2019 & 130387.92 & 37210.40 & 223565.43 & -12114.79 & 272890.63 \\ 
  Ago 2019 & 132344.02 & 39131.60 & 225556.44 & -10212.07 & 274900.11 \\ 
  Sep 2019 & 186135.59 & 92883.72 & 279387.47 & 43519.15 & 328752.03 \\ 
  Oct 2019 & 132958.80 & 39662.62 & 226254.97 & -9725.39 & 275642.98 \\ 
  Nov 2019 & 119264.96 & 25919.38 & 212610.54 & -23494.78 & 262024.70 \\ 
  Dic 2019 & 144147.58 & 50747.22 & 237547.95 & 1304.06 & 286991.11 \\ 
  Ene 2020 & 284962.40 & 191501.60 & 378423.20 & 142026.44 & 427898.36 \\ 
  Feb 2020 & 227801.71 & 134274.55 & 321328.87 & 84764.26 & 370839.16 \\ 
  Mar 2020 & 280249.06 & 186649.35 & 373848.78 & 137100.66 & 423397.47 \\ 
  Abr 2020 & 149543.11 & 55864.38 & 243221.83 & 6273.86 & 292812.35 \\ 
  May 2020 & 202268.87 & 108504.42 & 296033.32 & 58868.52 & 345669.22 \\ 
  Jun 2020 & 186796.14 & 92938.98 & 280653.30 & 43254.00 & 330338.28 \\ 
   \hline
\end{tabular}
\end{table}

El pronóstico realizado para los siguientes 24 periodos logra captar de buena manera los cambios en la serie en comparación a los ocurridos en el pasado para los dos mejores modelos, es decir, los Holt-Winters aditivo y multiplicativo. Además, los intervalos de confianza cubren un margen tal que es congruente con lo mostrado en los periodos registrados más recientes.

\newpage

##### h.

```{r}
base %>% 
  group_by(año=year(Fecha)) %>% 
  summarise(Amortización=sum(Amortización)) %>% 
  merge(., PIBreal, by="año") %>% 
  mutate(Amortización=log(Amortización), PIB=log(PIB)) %>% 
  gather(tipo, valor, -año) %>% 
  #mutate(porcentaje=round(suma/PIB*100, 2)) %>% 
  ggplot(., aes(x=año, y=valor, colour=tipo))+
  geom_line(size=1.3)+
  theme_minimal() +
  theme(text = element_text(size=9),
      axis.text.x = element_text(angle=0, hjust=1),
        legend.title=element_blank()) +
  ggtitle("Crecimiento del PIB y Amortización en Costa Rica 2007-2017") +
  labs(caption="Fuente: SIGAF",
       y="Amortización/PIB (escala logarítmica)",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                margin=margin(t=1,10,10,10))) +
  #ylim(7,12) 
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

El gráfico anterior muestra que la amortización posee un comportamiento bastante irregular, por lo cual no es predecible.

### 3.

##### a.

Pensión: subsidio que recibe una persona de manera temporal o de por vida, debido a distintas situaciones establecidas por ley en cada país. En el caso de Costa Rica, está el subsidio por invalidez, vejez y muerte. En Costa Rica, en el caso de los asalariados el patrono debe brindar una cantidad de dinero para el fondo de pensiones de cada uno de sus empleadores.

Esta serie representa los gastos en pensiones que tiene el sector público en millones de colones de Costa Rica de enero 2007 a junio 2018.

\newpage

##### b.

```{r}
base <- read_excel("C:\\Users\\Dell\\OneDrive\\Academico\\Proyectos\\GitHub\\Academico\\Cursos\\SP-1633 Series Cronológicas\\Examenes\\Parcial I\\Datos examen1.xlsx", sheet = 3)
```

```{r}
TS <- ts(base$Pensiones, start = c(2007, 1), end = c(2018, 6), frequency = 12)
```

```{r}
data.frame(MMC=ma(TS, order=10), Serie=TS, fecha=base$Fecha) %>% 
  gather(Tipo, valor, -fecha) %>% 
  ggplot(., aes(x=fecha, y=valor, colour=Tipo))+
  geom_line(size=1.3)+
  #theme_minimal() +
  theme(text = element_text(size=9),
      axis.text.x = element_text(angle=0, hjust=1),
        legend.title=element_blank()) +
  ggtitle("Gráfico 10: Media móvil centrada de orden 10") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos salariales",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                margin=margin(t=1,10,10,10))) 
  #ylim(7,12) 
  #scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

Al aplicar las medias móviles de orden 10 se logra captar el comportamiento de la serie en referencia a su crecimiento, el cual parece ser constante a lo largo del tiempo.

##### c.

```{r}
train <- base %>% 
  filter(Fecha<"2016-06-01")
train <- ts(train$Pensiones, start = c(2007, 1), frequency = 12)
train.serie <- window(train, 2007)
test <- base %>% 
  filter(Fecha>"2016-06-01")
test <- ts(test$Pensiones, start = c(2016, 7), frequency = 12)
test.serie <- window(test, c(2016, 7))
TS <- ts(base$Pensiones, start = c(2007, 1), end = c(2018, 6), frequency = 12)
```

```{r}
mod1 <- tslm(train.serie ~ trend + season)
mod2 <- hw(train.serie, model="AAM")
```

* Regresión con tendencia estacionalidad:

$$
\begin{aligned}
\hat y_t=20473.1+378.4t+1763.8s_2+1433.4s_3+1009.7s_4+2129.3s_5+766.2s_6\\
+891.3s_7+853.8s_8+3494.2s_9+2153.2s_{10}+2388.7s_{11}+36751.8s_{12}
\end{aligned}
$$

* Holt-Winters multiplicativo con errores aditivos

$$
\begin{aligned}
\hat y_{t+h|t}=(l_t+hb_t)s_{t+h-m(k+1)};con\\
lt=0.0887\left(\frac{y_t}{s_{t-m}}\right)+(1-0.0887)(l_{t-1}+b_{t-1})\\
bt=0.0001(l_t-l_{t-1})+(1-0.0001)b_{t-1}\\
s_t=0.7687\left(\frac{y_t}{-l_{t-1}-b_{t-1}}\right)+(1-0.7687)s_{t-m}
\end{aligned}
$$

\newpage

##### d.

```{r}
informacion <- medidas1(mod1, "Regresion") %>% 
  spread(tipo, medida)
rendimiento <- medidas2(mod1, 24, "Regresion")

criterios <- merge(informacion, rendimiento, by="Modelo", all = TRUE)
mhw <- data.frame(Modelo=c("Holt-Winters Multiplicativo", "Holt-Winters Multiplicativo Validacion"),
           AIC=c(2359.951, NA),
           AICc=c(2366.326, NA),
           BIC=c(2406.466, NA), 
           MAE=c(1554.261, 1897.094),
           MAPE=c(3.288099, 2.584386),
           MASE=c(0.3353169, 0.4092797),
           RMSE=c(2523.597, 2843.705))

mediciones <- do.call("rbind", list(criterios, mhw))
```

```{r, eval=FALSE}
tabla(mediciones, "entrenamiento")
```

![](C:\\Users\\Dell\\Desktop\\Imagenes\\3d.png)

Las medidas de criterio de información ofrecen mejores resultados en el modelo de regresión (figura 5), mientras que entre las medidas clásicas, solo el MAPE es mejor en este modelo. Sin embargo, el resto de medidas clásicas son bastante similares entre ambos modelos, por lo que se decide que el mejor modelo en el conjunto de entrenamiento es el de regresión.

\newpage

##### e.

```{r, eval=FALSE}
tabla(mediciones, "validacion")
```

![](C:\\Users\\Dell\\Desktop\\Imagenes\\3e.png)

Como muestra la figura 6, el mejor modelo resulta ser el Holt-Winters Multiplicativo con errores aditivos. En este caso la diferencia es mayor que en el caso del conjunto de entrenamiento.

Como en el conjunto de entrenamiento las medidas de rendimiento eran más parejas pero en el de validación es mucho mejor el Holt-Winters Multiplicativo con errores aditivos, es este último el que se decide usar como modelo final.

##### f.

```{r}
serie.completa <- window(TS, start=2007)
modfinal <- hw(serie.completa, model="AAM")
modfinal %>% 
  forecast(h=24) %>%
  autoplot() +
  theme_minimal() +
  theme(text = element_text(size=9),
        axis.text.x = element_text(angle=0, hjust=1),
        plot.title = element_text(size = 12))+
  labs(fill = "Nivel de confianza")+
  autolayer(fitted(modfinal), serie="Ajustados") +
  ggtitle("Gráfico 7: Pronóstico de la serie de gasto en pensiones en el periodo 2007 - 2018") +
  labs(caption="Fuente: SIGAF",
       y="Incentivos",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                  margin=margin(t=1,10,10,10))) +
  #ylim(7,12) +
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

```{r, eval=FALSE}
forecast(modfinal, h=24)
```

\begin{table}[ht]
\centering
\begin{tabular}{rrrrrr}
  \hline
 & Pronostico & LI 80 & LS 80 & LI 95 & LS 95 \\ 
  \hline
Jul 2018 & 71229.09 & 67430.56 & 75027.63 & 65419.74 & 77038.45 \\ 
  Ago 2018 & 70763.01 & 66958.63 & 74567.39 & 64944.71 & 76581.31 \\ 
  Sep 2018 & 71267.06 & 67456.82 & 75077.31 & 65439.80 & 77094.33 \\ 
  Oct 2018 & 71718.50 & 67902.39 & 75534.62 & 65882.26 & 77554.75 \\ 
  Nov 2018 & 72280.88 & 68458.88 & 76102.89 & 66435.64 & 78126.13 \\ 
  Dic 2018 & 126061.01 & 122233.11 & 129888.91 & 120206.74 & 131915.27 \\ 
  Ene 2019 & 72101.52 & 68267.71 & 75935.33 & 66238.21 & 77964.82 \\ 
  Feb 2019 & 72814.73 & 68974.99 & 76654.46 & 66942.36 & 78687.09 \\ 
  Mar 2019 & 74683.12 & 70837.45 & 78528.78 & 68801.68 & 80564.56 \\ 
  Abr 2019 & 75839.49 & 71987.88 & 79691.10 & 69948.96 & 81730.02 \\ 
  May 2019 & 74900.65 & 71043.08 & 78758.22 & 69001.01 & 80800.29 \\ 
  Jun 2019 & 75098.22 & 71234.68 & 78961.75 & 69189.44 & 81006.99 \\ 
  Jul 2019 & 75457.32 & 70533.14 & 80381.51 & 67926.44 & 82988.21 \\ 
  Ago 2019 & 74991.24 & 70062.35 & 79920.14 & 67453.15 & 82529.33 \\ 
  Sep 2019 & 75495.30 & 70561.68 & 80428.91 & 67949.98 & 83040.61 \\ 
  Oct 2019 & 75946.73 & 71008.38 & 80885.09 & 68394.17 & 83499.29 \\ 
  Nov 2019 & 76509.12 & 71566.01 & 81452.22 & 68949.29 & 84068.94 \\ 
  Dic 2019 & 130289.24 & 125341.38 & 135237.10 & 122722.14 & 137856.34 \\ 
  Ene 2020 & 76329.75 & 71377.11 & 81282.38 & 68755.35 & 83904.15 \\ 
  Feb 2020 & 77042.96 & 72085.54 & 82000.37 & 69461.24 & 84624.67 \\ 
  Mar 2020 & 78911.35 & 73949.13 & 83873.56 & 71322.29 & 86500.40 \\ 
  Abr 2020 & 80067.72 & 75100.69 & 85034.74 & 72471.31 & 87664.13 \\ 
  May 2020 & 79128.88 & 74157.03 & 84100.73 & 71525.10 & 86732.66 \\ 
  Jun 2020 & 79326.45 & 74349.77 & 84303.13 & 71715.27 & 86937.62 \\ 
   \hline
\end{tabular}
\end{table}

El pronóstico hecho con un Holt-Winters multiplicativo con errores aditivos logra captar de una forma muy aceptable el comportamiento de la serie, incluso en los valores más altos de la misma. De igual forma el intervalo de confianza es congruente con los datos históricos, así como con su crecimiento a lo largo del tiempo.

\newpage

##### h. 

```{r}
base %>% 
  group_by(año=year(Fecha)) %>% 
  summarise(Pensiones=sum(Pensiones)) %>% 
  merge(., PIBreal, by="año") %>% 
  mutate(Pensiones=log(Pensiones), PIB=log(PIB)) %>% 
  gather(tipo, valor, -año) %>% 
  #mutate(porcentaje=round(suma/PIB*100, 2)) %>% 
  ggplot(., aes(x=año, y=valor, colour=tipo))+
  geom_line(size=1.3)+
  theme_minimal() +
  theme(text = element_text(size=9),
      axis.text.x = element_text(angle=0, hjust=1),
        legend.title=element_blank()) +
  ggtitle("Crecimiento del PIB y Pensiones en Costa Rica 2007-2017") +
  labs(caption="Fuente: SIGAF",
       y="Pensiones/PIB (escala logarítmica)",
       x="Año") +
  theme(plot.title = element_text(hjust = 0.5, face="plain"),
        plot.caption=element_text(hjust=0, vjust=0.5,
                                margin=margin(t=1,10,10,10))) +
  #ylim(7,12) 
  scale_x_discrete(expand = c(0,0), limits=c(2005, 2010, 2015))
```

El gráfico anterior muestra que la tasa de crecimiento de las pensiones es bastante similar a la del PIB. Podría plantearse una ley para regular el gasto y de esta manera igualar la tasa de cambio, sin embargo no es algo que parezca tan pertinente.















